<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2-SAT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/11/2-SAT/" class="article-date">
  <time datetime="2018-03-11T08:12:49.000Z" itemprop="datePublished">2018-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/2-SAT/">2-SAT 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>　　设这n个布尔变量为$x_1,x_2,\cdots, x_n$, 我们发现对于每一组限制例如$1=x_i\text{and }x_j$, 它总是可以转化为对于$x_i=\omega_1,x_j=\omega_2$时成立, 因此这一组表达式可以转化为当$x_i=\alpha$时, $x_j=\beta$时成立.<br>　　因此我们可以构建一个图的结构, 每个变量$x_i$被拆分成两个点$x_i=\text{false}$和$x_i=\text{true}$.表示$x_i$等于$\text{false or true}$.如果一组限制条件要求$x_{i\alpha}=true$时满足$x_{j\beta}=true$,就将这两个点连一条有向边$x_{i\alpha\rightarrow x_{j\beta}}$.同时还要对其<strong>逆否命题</strong>建立与其相反的边(<strong><em>这就是所谓的对称性</em></strong>), $x_{i\beta}\rightarrow x_{j\alpha}$.<br>　　对于这样建立出来的一个图满足什么样的关系时才存在$n$个变量的某组取值满足所有限制条件呢?<br>　　注意到如果对这个图求强联通分量, 同一分量中的两个点$x_i,x_j$满足这样的拓扑关系: 如果$x_{ia}$成立, 那么$x_{jb}$也必须成立. 因为它们处在一个环中.<br>　　而我们很容易注意到一个性质.</p>
<pre><code>两个不能同时满足(不相容)的点处于同一个强联通分量中, 则问题无解.
</code></pre><p>　　可以看出对一个变量$x_i$的两个限制条件$x_i=1\text{ or }x_i=0$是不相容的, 因此当其处于同一个强联通分量时, 问题无解.</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>　　在某些题目中, 不仅要求所有限制条件是否能满足,(即<strong>可行性问题</strong>);而且还进一步要求输出这$n$个变量的具体取值.这种情况下如何处理呢?<br>　　可以充分利用上题中对图的处理, 构建反向图(因为要从后往前推), 拓扑排序, 从后往前一步步推出方案.</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>　　下面这些题目都只需要建模然后就成为 2-SAT 问题了.<br><a href="http://www.cnblogs.com/zwfymqz/p/8482182.html" target="_blank" rel="external">POJ 3207</a><br><a href="http://www.cnblogs.com/zwfymqz/p/8483625.html" target="_blank" rel="external">BZOJ 1823</a><br><a href="http://www.cnblogs.com/zwfymqz/p/8485294.html" target="_blank" rel="external">洛谷 P3209</a><br><a href="http://www.cnblogs.com/zwfymqz/p/8484673.html" target="_blank" rel="external">BZOJ 2199</a><br><a href="http://www.cnblogs.com/zwfymqz/p/8482976.html" target="_blank" rel="external">POJ 3683</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/11/2-SAT/" data-id="cjftq8nui001ae0kekea7yw6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/2-SAT/">2-SAT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图论/">图论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-p3366" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/11/p3366/" class="article-date">
  <time datetime="2018-03-11T01:59:10.000Z" itemprop="datePublished">2018-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/模板/">模板</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/p3366/">P3366【模板】最小生成树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）<br>接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz</p>
<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><pre><code>4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
</code></pre><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><pre><code>7
</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="时空限制：1000ms-128M"><a href="#时空限制：1000ms-128M" class="headerlink" title="时空限制：1000ms,128M"></a>时空限制：1000ms,128M</h4><h4 id="数据规模："><a href="#数据规模：" class="headerlink" title="数据规模："></a>数据规模：</h4><p>对于20%的数据：N&lt;=5，M&lt;=20<br>对于40%的数据：N&lt;=50，M&lt;=2000<br>对于70%的数据：N&lt;=500，M&lt;=10000<br>对于100%的数据：N&lt;=5000，M&lt;=200000</p>
<h4 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h4><p>所以最小生成树的总边权为2+2+3=7</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　如题,Kruskal算法或者是Prim算法.Prim算法需要用堆优化, 二叉堆或者斐波那契堆或者是优先队列?<br>　　当然在稠密图中Prim算法优秀的多, 但是大家一般都用Kruskal算法水生成树, 因为好写一点吗?</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> edge&#123;</div><div class="line">	<span class="keyword">int</span> u,v,c;</div><div class="line">	edge()&#123;&#125;</div><div class="line">	edge(<span class="keyword">int</span> _u,<span class="keyword">int</span> _v,<span class="keyword">int</span> _c)&#123;</div><div class="line">		u=_u,v=_v,c=_c;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; s)<span class="keyword">const</span>&#123;</div><div class="line">		<span class="keyword">return</span> c&lt;s.c;</div><div class="line">	&#125;</div><div class="line">&#125;E[N];</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> f[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> s==f[s]?f[s]:f[s]=find(f[s]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</div><div class="line">		<span class="keyword">int</span> a,b,c;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">		E[i]=edge(a,b,c);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i]=i;</div><div class="line">	sort(E+<span class="number">1</span>,E+<span class="number">1</span>+m);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</div><div class="line">		<span class="keyword">int</span> fa=find(E[i].u);</div><div class="line">		<span class="keyword">int</span> fb=find(E[i].v);</div><div class="line">		<span class="keyword">if</span>(fa!=fb)&#123;</div><div class="line">			sum++;ans+=E[i].c;</div><div class="line">			f[fa]=fb;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(sum==n<span class="number">-1</span>)<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>参考<img src="https://www.luogu.org/blog/user29226/solution-p3366" alt="Yhy9630&#39;s blog"></li>
<li>Prim算法用二叉堆/斐波那契堆优化更好.<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500010</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> node&#123;</div><div class="line">    <span class="keyword">int</span> to,nxt,w;</div><div class="line">&#125;edge[MAXM];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> HeapNode&#123;</div><div class="line">    <span class="keyword">int</span> point,dist;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> HeapNode &amp;o) <span class="keyword">const</span>&#123;</div><div class="line">        <span class="keyword">return</span> dist&gt;o.dist;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue&lt;HeapNode,<span class="built_in">vector</span>&lt;HeapNode&gt;,greater&lt;HeapNode&gt; &gt;q;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> vis[MAXN];</div><div class="line"><span class="keyword">int</span> n,m,s,head[MAXN],dis[MAXN],tot,ans,cnt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</div><div class="line">    edge[++tot].to=v;</div><div class="line">    edge[tot].w=w;</div><div class="line">    edge[tot].nxt=head[u];</div><div class="line">    head[u]=tot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">    s=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</div><div class="line">        <span class="keyword">int</span> f,g,w;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;f,&amp;g,&amp;w);</div><div class="line">        add(f,g,w);</div><div class="line">        add(g,f,w);</div><div class="line">    &#125;</div><div class="line">    fill(dis+<span class="number">1</span>,dis+n+<span class="number">1</span>,INF);</div><div class="line">    dis[s]=<span class="number">0</span>;</div><div class="line">    vis[s]=<span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[s];i!=<span class="number">-1</span>;i=edge[i].nxt)&#123;</div><div class="line">        q.push((HeapNode)&#123;edge[i].to,edge[i].w&#125;);</div><div class="line">        dis[edge[i].to]=edge[i].w;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!q.empty()&amp;&amp;cnt&lt;n)&#123;</div><div class="line">        HeapNode ext=q.top();</div><div class="line">        q.pop();</div><div class="line">        <span class="keyword">if</span>(vis[ext.point])  <span class="keyword">continue</span>;</div><div class="line">        ++cnt;</div><div class="line">        ans+=ext.dist;</div><div class="line">        vis[ext.point]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[ext.point];i;i=edge[i].nxt)&#123;</div><div class="line">            <span class="keyword">if</span>(dis[edge[i].to]&gt;edge[i].w)&#123;</div><div class="line">                dis[edge[i].to]=edge[i].w;</div><div class="line">                q.push((HeapNode)&#123;edge[i].to,edge[i].w&#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(cnt=n) <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</div><div class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"orz"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/11/p3366/" data-id="cjftq8nxk0065e0kesorh3433" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模板/">模板</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生成树/">生成树</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spanningTrees" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/spanningTrees/" class="article-date">
  <time datetime="2018-03-10T14:05:29.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/spanningTrees/">生成树总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>　　图$G$的一个极小联通子图称为生成树.从图的一个顶点出发不重复的遍历每个顶点形成一棵生成树$G_1$, 它包含图中所有的顶点, 图中所有的边$E$被分为两个集合$B$和$T$, 其中$T$为生成树上的边, $G_1={V,T}$.生成树满足树的所有性质, 即有$|V|-1$条边,树上两个结点之间有唯一路径.</p>
<ul>
<li>利用深度优先遍历形成的生成树称为深度优先生成树/森林.</li>
<li>利用宽度优先遍历形成的生成树称为宽度优先生成树/森林.</li>
</ul>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>　　边权和最小的生成树称为 <strong><em>最小生成树</em></strong>.</p>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>　　Prim算法的基本步骤:</p>
<ul>
<li>选择$V$中任意一个点加入集合$U$.</li>
<li>在与$U$中点相连的边中选择最小的将其顶点加入$U$.</li>
<li>重复上述步骤直到$V=U$.</li>
</ul>
<p>　　上述算法的时间瓶颈在于维护与$U$中点相连的最小边, 利用斐波那契堆或者二叉堆可以将其优化到$O(E+V\log V)$或者是$O(E\log V)$.一般用优先队列就能将做到和Kruskal算法相似的算法复杂度.而且Prim算法优势在于稠密图, 除了在工程中, 一般不用斐波那契堆优化Prim算法, 它不是很好写.</p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>　　Kruskal算法的基本步骤:</p>
<ul>
<li>将所有边按大小排序.</li>
<li>从所有边中选择最小并且所联通两点不联通的边将其加入边集$E_1$.</li>
<li>重复上述步骤直到$E_1=|V|-1$.</li>
</ul>
<p>　　维护两点的连通性可以使用<strong><em>并查集</em></strong>, 时间复杂度$O(E\log E+E\alpha(V))$.</p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>　　因为对于Prim算法, 其时间复杂度与$E$相关性更小, 因此当图非常稠密时, 会具有更好的时间效率.在完全图等边数非常大的图中,Kruskal不如Prim算法优秀.</p>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><p>　　次小生成树有次小生成树和严格次小生成树两种, 后者要求次小生成树严格大于最小生成树.</p>
<h4 id="不严格次小生成树"><a href="#不严格次小生成树" class="headerlink" title="不严格次小生成树"></a>不严格次小生成树</h4><p>　　次小生成树与最小生成树的不同只有一条边的区别.所以要先求出最小生成树然后替换掉其中一条边.我们枚举不在最小生成树上的边,加上这条边,再删掉一条边产生一棵生成树来更新答案.所以我们需要求出每一条边所覆盖的边的最大值和次大值(不严格), 实际上就是两点之间的边中边权最大值,这个可以用倍增完成.<br>　　这道题目<a href="http://poj.org/problem?id=1679" target="_blank" rel="external">POJ1679 The Unique MST</a>就是利用不严格这一性质来求解树的最小生成树是否唯一.</p>
<h4 id="严格次小生成树"><a href="#严格次小生成树" class="headerlink" title="严格次小生成树"></a>严格次小生成树</h4><p>　　其不同于不严格的地方在于要求的次小生成树其边权和严格大于最小生成树, 根据上述不严格算法, 用一条非树边替换掉某一条树边可能会产生树边权等于非树边权的情况, 而这样产生的生成树也是最小生成树. 而不考虑相等的情况可能会遗漏答案, 因此最好的办法就是再维护一个树上路径的严格次大值.如果最大值等于非树边权就选用次大值, 可保证<strong>严格</strong>.这一值同样可以用倍增维护.</p>
<h3 id="图的生成树数量"><a href="#图的生成树数量" class="headerlink" title="图的生成树数量"></a>图的生成树数量</h3><p>　　Matrix-Tree 定理可以用来解决这么一类问题,求图的互异生成树个数.</p>
<h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>　　约定对于矩阵$A$, 其行列式为$det(A)$.首先对于有$N$个点的无向图, 有图的拉普拉斯矩阵$L$, 其第$i$行第$j$列元素为$L_{i,j}$, 则<br>$$<br>L_{i,j}=<br>\begin{cases}<br>\deg(v_i),  &amp;\text{if $i=j$}\\<br>-1, &amp;\text{if $i\not=j$ and $v_i$ is adjacent to $v_j$}\\<br>0, &amp;\text{otherwise}<br>\end{cases}<br>$$<br>, 其实拉普拉斯矩阵就是图的度数矩阵减去邻接矩阵.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>图的生成树个数为其拉普拉斯矩阵的任意一个代数余子式的值.
</code></pre><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>以后补充.</p>
<h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><ul>
<li>对于有向图来说, 其拉普拉斯矩阵为图的入度矩阵减去只有有向边的邻接矩阵.</li>
<li>对于有重边的图, 其邻接矩阵为边的数量, 点的度数包括重边.</li>
<li>自环对答案无影响去掉即可.</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="Luogu-P3366-【模板】最小生成树"><a href="#Luogu-P3366-【模板】最小生成树" class="headerlink" title="Luogu P3366 【模板】最小生成树"></a><a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="external">Luogu P3366 【模板】最小生成树</a></h4><p>描述如题.<br>做法如题.</p>
<h4 id="HDU-4786-Fibonacci-Tree"><a href="#HDU-4786-Fibonacci-Tree" class="headerlink" title="HDU 4786 Fibonacci Tree"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4786" target="_blank" rel="external">HDU 4786 Fibonacci Tree</a></h4><h5 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h5><p>　　给一张无向连通图，每条边可能是黑边或白边，问是否存在一棵生成树使得树上白边数量为斐波那契树?n,m&lt;=100000</p>
<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h5><p>　　如果把边权为黑还是白看成边权为$1$还是$0$的话, 黑白数量相等就是求一棵特定边权的生成树.而我们发现对于一棵边权为$N$的生成树, 替换掉其一条边可以让生成树的边权和为$N+1\text{ or}N-1$.而树的边权和不能超过一个极大值和极小值,即最大/最小生成树.求出最大和最小生成树的边权即可.</p>
<h4 id="BZOJ-3714-PA2014Kuglarz"><a href="#BZOJ-3714-PA2014Kuglarz" class="headerlink" title="BZOJ 3714 PA2014Kuglarz"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3714" target="_blank" rel="external">BZOJ 3714 PA2014Kuglarz</a></h4><h5 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h5><p>　　魔术师的桌子上有n个杯子排成一行，编号为1,2,…,n，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。花费$c_{ij}$元，魔术师就会告诉你杯子i,i+1,…,j底下藏有球的总数的奇偶性。<br>　　采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球?</p>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>　　要知道第$j$个杯子中存不存在球, 只需要知道$[1,j-1]$的奇偶性和$1,j]$的奇偶性.也就是说需要求出所有$[1,i],i\leq n$的奇偶性.<br>　　而如果我们知道了$[l,r]$和$[r+l,w]$的奇偶性, 就知道了$[l,w]$的奇偶性, 或者知道$[l,w]$和$[l,r]$的奇偶性, 就可以还原出$[r+1,w]$的奇偶性, 因此可以将它们之间的关系转化为图的关系.如果知道了$[l,r]$的奇偶性, 就连一条边$l\rightarrow r$, 得到球的分布的条件是图为连通图, 则容易看出答案为最小生成树.</p>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充."></a>待补充.</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/spanningTrees/" data-id="cjftq8ny6007re0keptneite6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生成树/">生成树</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Tarjan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/Tarjan/" class="article-date">
  <time datetime="2018-03-10T11:26:33.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/Tarjan/">Tarjan 算法应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>可以参考</p>
<ul>
<li><a href="https://www.byvoid.com/zhs/blog/biconnect" target="_blank" rel="external">byvoid’s blog</a></li>
<li><a href="http://blog.csdn.net/stillxjy/article/details/70176689" target="_blank" rel="external">STILLxjy’s blog</a></li>
<li><strong>感觉过多的解释并没有用, 多画图就能明白.</strong></li>
</ul>
<h3 id="强联通分量"><a href="#强联通分量" class="headerlink" title="强联通分量"></a>强联通分量</h3><p>　　定理: 一个图$G$是强联通的, 当且仅当$G$中有一个回路, 它至少包含每个节点一次.<br>　　Tarjan算法是基于这么一个原理, 因为如果进行深搜的话, 强联通分量中的一个点$u$至少会在遍历其强联通分量中的点时被第二次遍历到, 这也就是<strong>定理</strong>中的<strong>回路</strong>的含义, 在回溯的时候回能将其能到达的点的信息更新回来. 所以一般的做法是用能到达的点的搜索顺序(时间戳)的最小值, 将这个点作为这个强联通分量的根, 这个点(<em>强联通分量的根</em>)所在的搜索树就是其强联通分量.可以将其搜索到的根加入栈, 找到一个完整的强联通分量(回溯到根)时弹出栈内的点就是这个强联通分量.<br><img src="http://img.blog.csdn.net/20170414222220855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU1RJTEx4ank=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Png1"></p>
<h4 id="树边与回边"><a href="#树边与回边" class="headerlink" title="树边与回边"></a>树边与回边</h4><p>　　上图中的实边就是树边, 虚边就是回边.<br>　　树边是指边$(u,v)$其中$v$不曾被遍历过.回边的定义则与其相反.树边根据其字面含义就是在搜索树中的边, 而回边为从搜索树中回到其祖先的边.这是非常重要的一个概念.可以看出回边就是找出更新点的信息找出强联通分量的一个关键.</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>　　表明当前节点是第几个被访问到的, </p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    dfn[x]=low[x]=++dfn_tim;</div><div class="line">    vis[x]=<span class="literal">true</span>;<span class="built_in">stack</span>[++top]=x;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</div><div class="line">        <span class="keyword">int</span> to=e[i].v;</div><div class="line">        <span class="keyword">if</span>(!dfn[to])Tarjan(to),</div><div class="line">        low[x]=min(low[x],low[to]);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[to])low[x]=min(low[x],low[to]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</div><div class="line">        ++col_num;</div><div class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>[top]!=x)&#123;</div><div class="line">            <span class="keyword">int</span> Top=<span class="built_in">stack</span>[top];</div><div class="line">            col[Top]=col_num;</div><div class="line">            V[col_num]+=v[Top];</div><div class="line">            vis[Top]=<span class="literal">false</span>;</div><div class="line">            top--;</div><div class="line">        &#125;</div><div class="line">        col[x]=col_num;V[col_num]+=v[x];</div><div class="line">        vis[x]=<span class="literal">false</span>;top--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="无向图的割边-桥-和边双联通分量"><a href="#无向图的割边-桥-和边双联通分量" class="headerlink" title="无向图的割边(桥)和边双联通分量"></a>无向图的割边(桥)和边双联通分量</h3><pre><code>这里涉及的是无向图, 要和强联通分量区分开.　　
</code></pre><p>　　Tarjan算法可以求出无向图的边双联通分量, 也就是任何两点之间都会存在两条路径相互到达并且子图中不存在割边, 它不同于有向图Tarjan的地方在搜索一个点$v$时不能利用$(u&lt;-&gt;v)$这条边来进入$u$点.也就是说我们搜索一个点时需要记录它是从哪个点遍历过来的, 在继续遍历时不能再遍历这个点.</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</div><div class="line">    dfn[x]=low[x]=++dfn_tim;</div><div class="line">    vis[x]=<span class="literal">true</span>;<span class="built_in">stack</span>[++top]=x;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</div><div class="line">        <span class="keyword">int</span> to=e[i].v;</div><div class="line">		<span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(!dfn[to])Tarjan(to,x),</div><div class="line">	        low[x]=min(low[x],low[to]);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[to])low[x]=min(low[x],low[to]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</div><div class="line">        ++col_num;</div><div class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>[top]!=x)&#123;</div><div class="line">            <span class="keyword">int</span> Top=<span class="built_in">stack</span>[top];</div><div class="line">            col[Top]=col_num;</div><div class="line">            V[col_num]+=v[Top];</div><div class="line">            vis[Top]=<span class="literal">false</span>;</div><div class="line">            top--;</div><div class="line">        &#125;</div><div class="line">        col[x]=col_num;V[col_num]+=v[x];</div><div class="line">        vis[x]=<span class="literal">false</span>;top--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　定义: 无向图的割边是指删掉这条边之后图的联通分量会增加, 也就是割边连接这两个双联通分量.这两个双联通分量之间只有割边这一条边连接着.而一条边是割边就等价于$low_v&gt;dfn_u$, 表示他们它们不在一个双联通分量中.</p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</div><div class="line">    dfn[x]=low[x]=++dfn_tim;</div><div class="line">    vis[x]=<span class="literal">true</span>;<span class="built_in">stack</span>[++top]=x;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</div><div class="line">        <span class="keyword">int</span> to=e[i].v;</div><div class="line">		<span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(!dfn[to])&#123;</div><div class="line">			Tarjan(to,x),</div><div class="line">	        low[x]=min(low[x],low[to]);</div><div class="line">			<span class="keyword">if</span>(low[to]&gt;low[u])</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,u,to);</div><div class="line">		&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[to])low[x]=min(low[x],low[to]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</div><div class="line">        ++col_num;</div><div class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>[top]!=x)&#123;</div><div class="line">            <span class="keyword">int</span> Top=<span class="built_in">stack</span>[top];</div><div class="line">            col[Top]=col_num;</div><div class="line">            V[col_num]+=v[Top];</div><div class="line">            vis[Top]=<span class="literal">false</span>;</div><div class="line">            top--;</div><div class="line">        &#125;</div><div class="line">        col[x]=col_num;V[col_num]+=v[x];</div><div class="line">        vis[x]=<span class="literal">false</span>;top--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　但是这样在图中有重边的时候就会出现错误.因为它的判断是基于点所以当两点之间有超过一条边时将会判断错误.具体的解决方案有很多, 可以让其第二次访问到这两个点$(u,v)$之间的边时允许遍历$u$即可.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</div><div class="line">    dfn[u]=low[u]=++dfn_tim;</div><div class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</div><div class="line">        <span class="keyword">int</span> v=e[i].v;</div><div class="line">        <span class="keyword">if</span>(v==fa&amp;&amp;!flag)&#123;</div><div class="line">            flag=<span class="literal">true</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!dfn[v]) </div><div class="line">            Tarjan(v,u);</div><div class="line">        low[u]=min(low[u],low[v]);</div><div class="line">        <span class="keyword">if</span>(low[v]&gt;dfn[u])</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,u,v);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="无向图的割点-顶-和点双联通分量"><a href="#无向图的割点-顶-和点双联通分量" class="headerlink" title="无向图的割点(顶)和点双联通分量"></a>无向图的割点(顶)和点双联通分量</h3><p>　　无向图的点双联通分量和边双联通分量不同的地方在于两个点双联通分量最后有一个割点为公共点, 而两个边双联通分量最后有一个割边为公共边.<br>　　点双联通分量的定义于边双联通分量类似, 一个子图内部不存在割点为点双联通图, 其最大子图为点双联通分量.<br>　　当$(u,v)$为树边且$low_v\ge dfn_u$时,节点u才为割点.该式子的含义:以节点v为根的子树所能追溯到最早的祖先节点要么为v要么为u.点双联通分量就是栈中割点往上的点构成的图, 包括割点.<br>　　需要注意一个地方就是如果当前点为树根, 那么它为割点仅当其有两个以上的孩子, 这种情况需特殊判断.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</div><div class="line">    dfn[u]=low[u]=++dfn_tim;</div><div class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</div><div class="line">        <span class="keyword">int</span> v=e[i].v;</div><div class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</div><div class="line">			++children;</div><div class="line">            Tarjan(v,u);</div><div class="line">			low[u]=min(low[u],low[v]);</div><div class="line">			<span class="keyword">if</span>(!fa&amp;&amp;children&gt;<span class="number">1</span>)</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,u);</div><div class="line">			<span class="keyword">if</span>(fa&amp;&amp;low[v]&gt;=dfn[u])</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,u);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(v!=fa)low[u]=min(low[u],dfn[v]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/Tarjan/" data-id="cjftq8nty000ie0kexynxkl16" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/强联通分量/">强联通分量</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-matrix-treeTheorem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/matrix-treeTheorem/" class="article-date">
  <time datetime="2018-03-10T06:12:58.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/matrix-treeTheorem/">Matrix-Tree Theorem</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>　　约定对于矩阵$A$, 其行列式为$det(A)$.首先对于有$N$个点的无向图, 有图的拉普拉斯矩阵$L$, 其第$i$行第$j$列元素为$L_{i,j}$, 则<br>$$<br>L_{i,j}=<br>\begin{cases}<br>\deg(v_i),  &amp;\text{if $i=j$}\\<br>-1, &amp;\text{if $i\not=j$ and $v_i$ is adjacent to $v_j$}\\<br>0, &amp;\text{otherwise}<br>\end{cases}<br>$$<br>, 其实拉普拉斯矩阵就是图的度数矩阵减去邻接矩阵.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>图的生成树个数为其拉普拉斯矩阵的任意一个代数余子式的值.
</code></pre><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>以后补充.</p>
<h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><ul>
<li>对于有向图来说, 其拉普拉斯矩阵为图的入度矩阵减去只有有向边的邻接矩阵.</li>
<li>对于有重边的图, 其邻接矩阵为边的数量, 点的度数包括重边.</li>
<li>自环对答案无影响去掉即可.</li>
</ul>
<h3 id="例题1-SP104-HIGH-Highways"><a href="#例题1-SP104-HIGH-Highways" class="headerlink" title="例题1: SP104 HIGH - Highways"></a>例题1: <a href="http://www.spoj.com/problems/HIGH/" target="_blank" rel="external">SP104 HIGH - Highways</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h4><p>　　In some countries building highways takes a lot of time… Maybe that’s because there are many possiblities to construct a network of highways and engineers can’t make up their minds which one to choose. Suppose we have a list of cities that can be connected directly. Your task is to count how many ways there are to build such a network that between every two cities there exists exactly one path. Two networks differ if there are two cities that are connected directly in the first case and aren’t in the second case. At most one highway connects two cities. No highway connects a city to itself. Highways are two-way.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>　　The input begins with the integer t, the number of test cases (equal to about 1000). Then t test cases follow. The first line of each test case contains two integers, the number of cities (1&lt;=n&lt;=12) and the number of direct connections between them. Each next line contains two integers a and b, which are numbers of cities that can be connected. Cities are numbered from 1 to n. Consecutive test cases are separated with one blank line.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>　　The number of ways to build the network, for every test case in a separate line. Assume that when there is only one city, the answer should be 1. The answer will fit in a signed 64-bit integer.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><h5 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input:"></a>Sample input:</h5><pre><code>4
4 5
3 4
4 2
2 3
1 2
1 3

2 1
2 1

1 0

3 3
1 2
2 3
3 1
</code></pre><h4 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output:"></a>Sample output:</h4><pre><code>8
1
1
3
</code></pre><h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>　　使用Matrix-Tree定理求解, 行列式的求解可以用高斯消元.</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</div><div class="line"><span class="keyword">double</span> f[<span class="number">16</span>][<span class="number">16</span>];</div><div class="line"><span class="keyword">int</span> n,T,x,y,m;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (x&lt;=eps&amp;&amp;x&gt;=-eps)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> (x&gt;<span class="number">0</span>)?<span class="number">1</span>:<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</div><div class="line">    n--;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">        <span class="keyword">int</span> num=i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">            <span class="keyword">if</span>(dcmp(<span class="built_in">fabs</span>(f[j][i])-<span class="built_in">fabs</span>(f[num][i]))&gt;<span class="number">0</span>)num=j;</div><div class="line">        <span class="keyword">if</span>(dcmp(f[num][i])==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">"0"</span>);<span class="keyword">return</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(num!=i)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</div><div class="line">                swap(f[i][j],f[num][j]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">            <span class="keyword">if</span>(dcmp(f[j][i]))&#123;</div><div class="line">                <span class="keyword">double</span> t=f[j][i]/f[i][i];</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</div><div class="line">                    f[j][k]-=t*f[i][k];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        ans*=f[i][i];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%.0f\n"</span>,<span class="built_in">abs</span>(ans));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span>(T--)&#123;</div><div class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),</div><div class="line">            f[x][x]++,f[y][y]++,</div><div class="line">            f[x][y]--,f[y][x]--;</div><div class="line">        gauss();</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题2-BZOJ-1002-轮状病毒"><a href="#例题2-BZOJ-1002-轮状病毒" class="headerlink" title="例题2: BZOJ 1002 轮状病毒"></a>例题2: <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1002" target="_blank" rel="external">BZOJ 1002 轮状病毒</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>　　轮状病毒有很多变种，所有轮状病毒的变种都是从一个轮状基产生的。一个N轮状基由圆环上N个不同的基原子<br>和圆心处一个核原子构成的，2个原子之间的边表示这2个原子之间的信息通道。如下图所示</p>
<p>　　N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不<br>同的3轮状病毒，如下图所示</p>
<p>　　现给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒</p>
<h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>　　第一行有1个正整数n</p>
<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><p>　　计算出的不同的n轮状病毒数输出</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>3</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>16</p>
<h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法:"></a>做法:</h4><p>　　本来用Matrix-tree定理一顿猛做应该是可以过掉的, 但是用高斯消元貌似会被卡精度, 但是行列式有太多方法可以求了, 但是这个题目有一个比较不正常的递推解法.高斯消元也可以尝试高精度小数等鬼畜解法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/matrix-treeTheorem/" data-id="cjftq8nvk0030e0kexuxczonf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Matrix-Tree/">Matrix-Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生成树/">生成树</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bzoj4289" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/bzoj4289/" class="article-date">
  <time datetime="2018-03-10T01:35:45.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/bzoj4289/">BZOJ4289 PA2012 Tax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="BZOJ-4289-PA2012-Tax"><a href="#BZOJ-4289-PA2012-Tax" class="headerlink" title="BZOJ 4289: PA2012 Tax"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4289" target="_blank" rel="external">BZOJ 4289: PA2012 Tax</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　给出一个N个点M条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点1到点N的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权N&lt;=100000M&lt;=200000</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4 5
1 2 5
1 3 2
2 3 1
2 4 4
3 4 8
</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>12
</code></pre><h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　这里要使用特殊的建图方式, 因为路径权值计算方法比较特殊, 一般的建图方式无法处理.</p>
<ul>
<li>首先可以考虑将边转化为点来建图, 这样边权就是原图中两条边也就是新建的图中两个点权值较大的值, 将源点向所有连向边建边, 将汇点向所有通向汇点的边建边, 使用最短路算法可以得到答案.但是这样对于点$v$, 所有满足$u\rightarrow v, v\rightarrow w$的边$(u,v),(v,w)$之间都要连边, 新图中边的数量是巨大的.</li>
<li>考虑减少连边的数量, 首先将$v$的所有出边按权值排序, 然后将所有$v$的入边$u_i$向与其相差最小的$v$的出边$w_0$连边, 再在$v$的所有出边$w_0,w_1,w_2,w_3,\cdots $之间互相连边, 边权为权值差, 使得通过$u_i$能到达任意$w_i$.这样边的数量就被缩小到$M$级别了.<br><img src="/myjson/3.10.png" alt="Png1"></li>
<li>这样连边其实和将$v$的入边和出边之间依次连边效果是相同的, 而且对于无向图, 这样连边其实是更好的, 大多数这道题的题解都是这么连边的.</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Pair pair<span class="meta-string">&lt;long long,int&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge&#123;</div><div class="line">    <span class="keyword">int</span> u,v,w,nxt;</div><div class="line">&#125;E[N];</div><div class="line"><span class="keyword">int</span> headE[N],numE;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</div><div class="line">    E[numE]=(Edge)&#123;x,y,z,headE[x]&#125;;headE[x]=numE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node&#123;</div><div class="line">    <span class="keyword">int</span> u,v,w,nxt;</div><div class="line">&#125;e[N];</div><div class="line"><span class="keyword">int</span> head[N],num;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</div><div class="line">    e[++num]=(Node)&#123;x,y,z,head[x]&#125;;head[x]=num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N,M,S,T;</div><div class="line"><span class="keyword">int</span> temp[N];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span>  dis[N];</div><div class="line"><span class="keyword">bool</span> vis[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(dis,<span class="number">0xf</span>,<span class="keyword">sizeof</span>(dis));dis[S]=<span class="number">0</span>;</div><div class="line">    priority_queue&lt;Pair&gt;q;</div><div class="line">    q.push(make_pair(<span class="number">0</span>,S));</div><div class="line">    <span class="keyword">while</span>(q.size()!=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">while</span>(vis[q.top().second]&amp;&amp;q.size()&gt;<span class="number">0</span>) q.pop();</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  p=q.top().second;</div><div class="line">        vis[p]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[p];i;i=e[i].nxt)</div><div class="line">            <span class="keyword">if</span>(dis[e[i].v]&gt;dis[p]+e[i].w)</div><div class="line">                dis[e[i].v]=dis[p]+e[i].w,</div><div class="line">                q.push(make_pair(-dis[e[i].v],e[i].v));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> E[a].w&lt;E[b].w;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    N=read();M=read();S=<span class="number">1</span>,T=<span class="number">2</span>*(M+<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</div><div class="line">        <span class="keyword">int</span> x=read(),y=read(),z=read();</div><div class="line">        add_edge(x,y,z);</div><div class="line">        add_edge(y,x,z);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">        <span class="keyword">int</span> tempnum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=headE[i];j;j=E[j].nxt)</div><div class="line">            temp[++tempnum]=j;</div><div class="line">        sort(temp+<span class="number">1</span>,temp+tempnum+<span class="number">1</span>,comp);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tempnum;j++)&#123;</div><div class="line">            <span class="keyword">int</span> x=temp[j],y=temp[j+<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span>(E[x].u==<span class="number">1</span>) </div><div class="line">                AddEdge(S,x,E[x].w);</div><div class="line">            <span class="keyword">if</span>(E[x].v==N) </div><div class="line">                AddEdge(x,T,E[x].w);</div><div class="line">            AddEdge(x^<span class="number">1</span>,x,E[x].w);</div><div class="line">            <span class="keyword">if</span>(j!=tempnum)</div><div class="line">                AddEdge(x,y,E[y].w-E[x].w),</div><div class="line">                AddEdge(y,x,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Dijstra();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[T]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/bzoj4289/" data-id="cjftq8num001ee0ketdq26mzg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最短路/">最短路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bzoj4152" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/bzoj4152/" class="article-date">
  <time datetime="2018-03-09T23:40:57.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/bzoj4152/">BZOJ 4152 [AMPPZ2014]The Captain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4152-AMPPZ2014-The-Captain"><a href="#4152-AMPPZ2014-The-Captain" class="headerlink" title="4152: [AMPPZ2014]The Captain"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4152" target="_blank" rel="external">4152: [AMPPZ2014]The Captain</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　给定平面上的n个点，定义(x1,y1)到(x2,y2)的费用为min(|x1-x2|,|y1-y2|)，求从1号点走到n号点的最小费用。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　第一行包含一个正整数n(2&lt;=n&lt;=200000)，表示点数。<br>　　接下来n行，每行包含两个整数x[i],y<a href="0&lt;=x[i],y[i]&lt;=10^9">i</a>，依次表示每个点的坐标。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　一个整数，即最小费用。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5
2 2
1 1
4 5
7 1
6 7
</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2
</code></pre><p>HINT<br>Source<br>鸣谢Claris上传</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　常规思路是, 将x,y上的距离分别连边, 因此可以将一个点$u(x,y)$连向所有$v(x_1,y_1)$, 距离分别是$|x_1-x|$和$|y_1-y|$.然后在用最短路算法解决.但是这样会产生$N^2$级别的边, 很明显是不合适的, 因此要减少边的数量.<br>　　可以观察到如果$u\rightarrow v=|x_v-x_u|,v\rightarrow w=|x_w-x_v|$那么边$u\rightarrow w=|x_w-x_u|$就等于上面两条边的和, 同理, 如果两个点之间的边由若干条同种类型的边连接而成( <em>都是x或者是y</em> ), 那么就不需要连接这条边.观察到这样能把边的数量压缩到$N$左右.<br>　　具体可以将所有点按x坐标和y坐标分别排序, 然后相邻点分别连边.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><p>　　卡SPFA是直接无法忍受.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge&#123;</div><div class="line">	<span class="keyword">int</span> v,c,nxt;</div><div class="line">&#125;e[N];</div><div class="line"><span class="keyword">int</span> head[N],tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span>&#123;</div><div class="line">	e[++tot]=(Edge)&#123;v,f,head[u]&#125;;head[u]=tot;</div><div class="line">	e[++tot]=(Edge)&#123;u,f,head[v]&#125;;head[v]=tot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Vector&#123;</div><div class="line">	<span class="keyword">int</span> x,y,id;</div><div class="line">	Vector(<span class="keyword">int</span> X=<span class="number">0</span>,<span class="keyword">int</span> Y=<span class="number">0</span>)&#123;x=x;y=y;&#125;</div><div class="line">	<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Vector&amp; s)<span class="keyword">const</span>&#123;</div><div class="line">		<span class="keyword">return</span> x&lt;s.x;</div><div class="line">	&#125;</div><div class="line">&#125;v[N];</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Vector&amp; a,<span class="keyword">const</span> Vector&amp; b)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> a.y&lt;b.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> dis[N],vis[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</div><div class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</div><div class="line">	que.push(<span class="number">1</span>);</div><div class="line">	vis[<span class="number">1</span>]=<span class="literal">true</span>;</div><div class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!que.empty())&#123;</div><div class="line">		<span class="keyword">int</span> top=que.front();que.pop();vis[top]=<span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[top];i;i=e[i].nxt)</div><div class="line">			<span class="keyword">if</span>(dis[e[i].v]&gt;dis[top]+e[i].c)&#123;</div><div class="line">				dis[e[i].v]=dis[top]+e[i].c;</div><div class="line">				<span class="keyword">if</span>(!vis[e[i].v])&#123;</div><div class="line">					que.push(e[i].v);</div><div class="line">					vis[e[i].v]=<span class="literal">true</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Cmp&#123;</div><div class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> dis[a]&gt;dis[b];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,Cmp&gt;que;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</div><div class="line">    que.push(<span class="number">1</span>);dis[<span class="number">1</span>]=<span class="number">0</span>;vis[<span class="number">1</span>]=<span class="literal">true</span>;</div><div class="line">    <span class="keyword">while</span>(!que.empty())&#123;</div><div class="line">        <span class="keyword">int</span> u=que.top();que.pop();vis[u]=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;</div><div class="line">            <span class="keyword">int</span> v=e[i].v;</div><div class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].c)&#123;</div><div class="line">                dis[v]=dis[u]+e[i].c;</div><div class="line">				<span class="keyword">if</span>(!vis[v])&#123;</div><div class="line">					que.push(v);</div><div class="line">					vis[v]=<span class="literal">true</span>;</div><div class="line">				&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">		v[i].id=i;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i].x,&amp;v[i].y);</div><div class="line">	&#125;</div><div class="line">	sort(v+<span class="number">1</span>,v+n+<span class="number">1</span>,cmp);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</div><div class="line">		AddEdge(v[i].id,v[i+<span class="number">1</span>].id,v[i+<span class="number">1</span>].y-v[i].y);</div><div class="line">	sort(v+<span class="number">1</span>,v+n+<span class="number">1</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</div><div class="line">		AddEdge(v[i].id,v[i+<span class="number">1</span>].id,v[i+<span class="number">1</span>].x-v[i].x);</div><div class="line"><span class="comment">//	spfa();</span></div><div class="line">	dijkstra();</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[n]);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/bzoj4152/" data-id="cjftq8nue0013e0kev0ud0gho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/堆优化Dijkstra/">堆优化Dijkstra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最短路/">最短路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bzoj2763" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/bzoj2763/" class="article-date">
  <time datetime="2018-03-09T23:22:02.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/bzoj2763/">BZOJ 2763 JLOI2011 飞行路线</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。<br>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。(0&lt;=s,t&lt;n)<br>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。(0&lt;=a,b&lt;n,a与b不相等，0&lt;=c&lt;=1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　只有一行，包含一个整数，为最少花费。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>5 6 1<br>0 4<br>0 1 5<br>1 2 5<br>2 3 5<br>3 4 5<br>2 3 3<br>0 2 100</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>8</p>
<h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于30%的数据,2&lt;=n&lt;=50,1&lt;=m&lt;=300,k=0;<br>对于50%的数据,2&lt;=n&lt;=600,1&lt;=m&lt;=6000,0&lt;=k&lt;=1;<br>对于100%的数据,2&lt;=n&lt;=10000,1&lt;=m&lt;=50000,0&lt;=k&lt;=10.</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　拆点, 将每个点拆成$k+1$个点, 第i个节点$(u,i)$表示从起点到$u$恰好使用了$i$次免费机会, 对于原图中的边$(u,v)$除了原本的边$u\rightarrow v$外, 还需建边$(u,i)\rightarrow (v,i)$和$(u,i)\rightarrow (v,i+1)$, 表示使用了一次免费机会, 最后求最短路就是答案.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> n,m,k,nn;</div><div class="line"><span class="keyword">int</span> s,t;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Edge&#123;</div><div class="line">    <span class="keyword">int</span> v,c,nxt;</div><div class="line">&#125;e[N*<span class="number">5</span>];</div><div class="line"><span class="keyword">int</span> head[N],tot;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> uu=u*(k+<span class="number">1</span>),vv=v*(k+<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)&#123;</div><div class="line">        e[++tot]=(Edge)&#123;vv+i,c,head[uu+i]&#125;;head[uu+i]=tot;</div><div class="line">        e[++tot]=(Edge)&#123;uu+i,c,head[vv+i]&#125;;head[vv+i]=tot;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</div><div class="line">        e[++tot]=(Edge)&#123;vv+i+<span class="number">1</span>,<span class="number">0</span>,head[uu+i]&#125;;head[uu+i]=tot;</div><div class="line">        e[++tot]=(Edge)&#123;uu+i+<span class="number">1</span>,<span class="number">0</span>,head[vv+i]&#125;;head[vv+i]=tot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> dis[N];</div><div class="line"><span class="keyword">int</span> vis[N];</div><div class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</div><div class="line">    <span class="keyword">int</span> ss=s*(k+<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)&#123;</div><div class="line">        dis[ss+i]=<span class="number">0</span>;</div><div class="line">        vis[ss+i]=<span class="literal">true</span>;</div><div class="line">        que.push(ss+i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!que.empty())&#123;</div><div class="line">        <span class="keyword">int</span> t=que.front();que.pop();</div><div class="line">        vis[t]=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[t];i;i=e[i].nxt)&#123;</div><div class="line">            <span class="keyword">if</span>(dis[e[i].v]&gt;dis[t]+e[i].c)&#123;</div><div class="line">                 dis[e[i].v]=dis[t]+e[i].c;</div><div class="line">                <span class="keyword">if</span>(!vis[e[i].v])&#123;</div><div class="line">                    que.push(e[i].v);</div><div class="line">                    vis[e[i].v]=<span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// for(int i=0;i&lt;nn;++i)</span></div><div class="line">    <span class="comment">//    cout&lt;&lt;dis[i]&lt;&lt;' ';</span></div><div class="line">    <span class="comment">// cout&lt;&lt;endl;</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </div><div class="line">    <span class="comment">// freopen("a.in","r",stdin);</span></div><div class="line">    <span class="comment">// freopen("a.out","w",stdout);</span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</div><div class="line">    nn=n*(k+<span class="number">1</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</div><div class="line">        <span class="keyword">int</span> a,b,c;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</div><div class="line">        AddEdge(a,b,c);</div><div class="line">    &#125;</div><div class="line">    spfa(s);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t*(k+<span class="number">1</span>)+k]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/bzoj2763/" data-id="cjftq8nv60028e0keuoksvcas" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拆点/">拆点</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最短路/">最短路</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gameall" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/gameall/" class="article-date">
  <time datetime="2018-03-09T22:50:50.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/gameall/">博弈论总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><p><a href="http://aiyoupass.com/2018/p2197/">Luogu P2197 nim游戏</a><br><a href="http://aiyoupass.com/2018/sgTheorem/">SG函数和SG定理</a><br><a href="http://aiyoupass.com/2018/Fib-SG/">斐波那契博弈</a><br><a href="http://aiyoupass.com/2018/weizuofuth/">威佐夫博弈</a><br><a href="http://aiyoupass.com/2018/Multi-SG/">Multi-SG</a><br><a href="http://aiyoupass.com/2018/Anti-SG/">Anti-SG/Misère Games</a><br><a href="http://aiyoupass.com/2018/Every-SG/">Every-SG</a></p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><a href="http://aiyoupass.com/2018/easygame/">简单博弈论题目选做</a><br><a href="http://aiyoupass.com/2018/uoj266/">UOJ266. 【清华集训2016】Alice和Bob又在玩游戏</a><br><a href="http://aiyoupass.com/2018/cf842d/">CF 842D D. Vitya and Strange Lesson</a><br><a href="http://aiyoupass.com/2018/p4077/">P4077 [SDOI2016]硬币游戏</a></p>
<h3 id="with-draw"><a href="#with-draw" class="headerlink" title="with draw"></a>with draw</h3><p><a href="http://www.cnblogs.com/qdscwyy/p/8503198.html" target="_blank" rel="external">NEERC 2016-2017 Probelm G. Game on Graph</a><br><a href="http://www.cnblogs.com/qdscwyy/p/8503197.html" target="_blank" rel="external">CodeForces 786a</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/gameall/" data-id="cjftq8nvc002le0kehlr3kl9z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-neercproblem-g" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/03/neercproblem-g/" class="article-date">
  <time datetime="2018-03-03T14:25:40.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/03/neercproblem-g/">NEERC 2016-2017 Probelm G. Game on Graph</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://codeforces.com/gym/101190/submit" target="_blank" rel="external">NEERC 2016-2017 Probelm G. Game on Graph</a></p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　Gennady and Georgiy are playing interesting game on a directed graph. The graph has n vertices and m arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.</p>
<p>　　For each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.</p>
<p>　　On one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.</p>
<p>　　On the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely.<br>Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.<br>Both players are playing optimally. Both players know preferences of the other player.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　In the first line there are two integers — the number of vertices n (1 ≤ n ≤ 100 000) and the number of arcs m (1 ≤ m ≤ 200 000). In the next m lines there are two integers a and b on each line, denoting an arc from vertex a to vertex b. Vertices are numbered from 1 to n. Each (a, b) tuple appears at most once.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　In the first line print n characters — i-th character should denote the result of the game if Gennady starts in vertex i. In the second line print n characters — i-th character should denote the result of the game if Georgiy starts in vertex i. The result of the game is denoted by “W” if the starting player wins the game, “L” if the starting player loses the game, and “D” (draw) if the game runs infinitely.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>6 7<br>1 2<br>2 1<br>2 3<br>1 4<br>4 1<br>4 5<br>5 6<br>WDLDWL<br>DWLLWL<br><img src="https://i.loli.net/2018/03/03/5a9a8ba339f04.png" alt="Png1"></p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>　　In vertices 3 and 6 the game is already lost. In vertex 5, the only move is to vertex 6, and the player wins. If Georgiy starts in vertex 1, or Gennady in vertices 2 or 4, Gennady can always go to vertex 1, and make the game infinite. If Georgiy starts in vertex 4, he can either go to vertex 1 (which leads to a draw) or to vertex 5, which leads to losing. Georgiy prefers the latter. Similarly, from vertex 2, he prefers to go to 3 and win. From vertex 1, Gennady can go to vertex 2 and lose, or go to vertex 4 and win. He prefers the latter.</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　首先这道题特殊的地方在于玩家二的特殊要求, 对它来说输比平局要好.所以我们在利用后继状态确立胜负的时候, 就要做出一些改变.</p>
<ul>
<li>对于玩家二为先手来说, 如果一个状态的后继状态有一个不为平局, 那么一定不为平局.</li>
<li>对于玩家一为先手来说, 如果一个状态的后继状态都不为平局, 其一定不为平局.<br>　　先利用拓扑排序确立出平局状态, 平局状态一定不会出现在拓扑序中.接着标记出所有的胜负状态, 剩下那些没有被标记的就是可能为平局状态, 但是因为玩家二的特殊, 所以这些状态一定是玩家一胜利.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/03/neercproblem-g/" data-id="cjftq8nvw003ke0ket0os70gi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/with-draw/">with draw</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/">信息学竞赛</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/其它/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/我的文档/">我的文档</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/考试/">考试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/题目/">题目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/题目/模板/">模板</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/其它/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数学/线性代数/">线性代数</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/">解决方案</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/LaTeX/">LaTeX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/VSCode/">VSCode</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2-SAT/">2-SAT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anti-SG/">Anti-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Beatty定理/">Beatty定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDQ分治/">CDQ分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CodeForces/">CodeForces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debug/">Debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Every-SG/">Every-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICG/">ICG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/">LaTeX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lasker-s-Nim/">Lasker's Nim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Link-Cut-Tree/">Link-Cut-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matrix-Tree/">Matrix-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misere-Games/">Misère Games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multi-SG/">Multi-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NOIP/">NOIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDOI/">SDOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG函数/">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TikZ/">TikZ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/">Trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zeckendorf定理/">Zeckendorf定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/copyright/">copyright</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/document/">document</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lca/">lca</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim/">nim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pb-ds/">pb_ds</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pdf/">pdf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source/">source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/with-draw/">with draw</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/一堆简单题/">一堆简单题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三维偏序/">三维偏序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分/">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分答案/">二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维前缀和/">二维前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维线段树/">二维线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二进制拆分/">二进制拆分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/倍增/">倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存池/">内存池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/决策单调性/">决策单调性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分块/">分块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分数规划/">分数规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前缀和/">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区间dp/">区间dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调栈/">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调队列/">单调队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博弈论/">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀数组/">后缀数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/四边形不等式优化/">四边形不等式优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文串/">回文串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基环树/">基环树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆优化Dijkstra/">堆优化Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重标记/">多重标记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重背包/">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/威佐夫博弈/">威佐夫博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/差分约束/">差分约束</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/巴什博弈/">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带权并查集/">带权并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平衡树/">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异或/">异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强制在线/">强制在线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强联通分量/">强联通分量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并排序/">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速幂/">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打表/">打表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展欧几里得/">扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拆点/">拆点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/指针/">指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排列组合/">排列组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契博弈/">斐波那契博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契数列/">斐波那契数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斜率优化/">斜率优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无限/">无限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大公约数/">最大公约数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大流/">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长上升子序列/">最长上升子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长公共子序列/">最长公共子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构造/">构造</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查分/">查分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树形dp/">树形dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模拟/">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉函数/">欧拉函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版权信息/">版权信息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生成树/">生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/矩阵快速幂/">矩阵快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/秦九韶算法/">秦九韶算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/等差数列/">等差数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性代数/">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/考试/">考试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包/">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/艺术/">艺术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/莫比乌斯反演/">莫比乌斯反演</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规律/">规律</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/解决方案/">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心/">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆元/">逆元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆序对/">逆序对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/错位排列数/">错位排列数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题目/">题目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高精/">高精</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/2-SAT/" style="font-size: 10px;">2-SAT</a> <a href="/tags/Anti-SG/" style="font-size: 10px;">Anti-SG</a> <a href="/tags/Beatty定理/" style="font-size: 11.25px;">Beatty定理</a> <a href="/tags/CDQ分治/" style="font-size: 10px;">CDQ分治</a> <a href="/tags/CodeForces/" style="font-size: 10px;">CodeForces</a> <a href="/tags/Debug/" style="font-size: 10px;">Debug</a> <a href="/tags/Every-SG/" style="font-size: 10px;">Every-SG</a> <a href="/tags/Floyd/" style="font-size: 10px;">Floyd</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/ICG/" style="font-size: 11.25px;">ICG</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/Lasker-s-Nim/" style="font-size: 10px;">Lasker's Nim</a> <a href="/tags/Link-Cut-Tree/" style="font-size: 10px;">Link-Cut-Tree</a> <a href="/tags/Matrix-Tree/" style="font-size: 10px;">Matrix-Tree</a> <a href="/tags/Misere-Games/" style="font-size: 10px;">Misère Games</a> <a href="/tags/Multi-SG/" style="font-size: 11.25px;">Multi-SG</a> <a href="/tags/NOIP/" style="font-size: 17.5px;">NOIP</a> <a href="/tags/Python/" style="font-size: 11.25px;">Python</a> <a href="/tags/SDOI/" style="font-size: 10px;">SDOI</a> <a href="/tags/SG函数/" style="font-size: 10px;">SG函数</a> <a href="/tags/Tarjan/" style="font-size: 10px;">Tarjan</a> <a href="/tags/TikZ/" style="font-size: 10px;">TikZ</a> <a href="/tags/Trie/" style="font-size: 12.5px;">Trie</a> <a href="/tags/Zeckendorf定理/" style="font-size: 10px;">Zeckendorf定理</a> <a href="/tags/bfs/" style="font-size: 10px;">bfs</a> <a href="/tags/copyright/" style="font-size: 10px;">copyright</a> <a href="/tags/document/" style="font-size: 12.5px;">document</a> <a href="/tags/lca/" style="font-size: 10px;">lca</a> <a href="/tags/nim/" style="font-size: 11.25px;">nim</a> <a href="/tags/pb-ds/" style="font-size: 10px;">pb_ds</a> <a href="/tags/pdf/" style="font-size: 16.25px;">pdf</a> <a href="/tags/source/" style="font-size: 10px;">source</a> <a href="/tags/with-draw/" style="font-size: 11.25px;">with draw</a> <a href="/tags/一堆简单题/" style="font-size: 10px;">一堆简单题</a> <a href="/tags/三维偏序/" style="font-size: 10px;">三维偏序</a> <a href="/tags/二分/" style="font-size: 10px;">二分</a> <a href="/tags/二分答案/" style="font-size: 11.25px;">二分答案</a> <a href="/tags/二维前缀和/" style="font-size: 10px;">二维前缀和</a> <a href="/tags/二维线段树/" style="font-size: 10px;">二维线段树</a> <a href="/tags/二进制拆分/" style="font-size: 10px;">二进制拆分</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/倍增/" style="font-size: 13.75px;">倍增</a> <a href="/tags/内存池/" style="font-size: 11.25px;">内存池</a> <a href="/tags/决策单调性/" style="font-size: 10px;">决策单调性</a> <a href="/tags/分块/" style="font-size: 11.25px;">分块</a> <a href="/tags/分数规划/" style="font-size: 11.25px;">分数规划</a> <a href="/tags/前缀和/" style="font-size: 10px;">前缀和</a> <a href="/tags/动态规划/" style="font-size: 20px;">动态规划</a> <a href="/tags/区间dp/" style="font-size: 10px;">区间dp</a> <a href="/tags/单调栈/" style="font-size: 10px;">单调栈</a> <a href="/tags/单调队列/" style="font-size: 11.25px;">单调队列</a> <a href="/tags/博弈论/" style="font-size: 18.75px;">博弈论</a> <a href="/tags/后缀数组/" style="font-size: 11.25px;">后缀数组</a> <a href="/tags/四边形不等式优化/" style="font-size: 10px;">四边形不等式优化</a> <a href="/tags/回文串/" style="font-size: 10px;">回文串</a> <a href="/tags/图论/" style="font-size: 13.75px;">图论</a> <a href="/tags/基环树/" style="font-size: 10px;">基环树</a> <a href="/tags/堆优化Dijkstra/" style="font-size: 10px;">堆优化Dijkstra</a> <a href="/tags/多重标记/" style="font-size: 10px;">多重标记</a> <a href="/tags/多重背包/" style="font-size: 10px;">多重背包</a> <a href="/tags/威佐夫博弈/" style="font-size: 11.25px;">威佐夫博弈</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/差分约束/" style="font-size: 11.25px;">差分约束</a> <a href="/tags/巴什博弈/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/带权并查集/" style="font-size: 10px;">带权并查集</a> <a href="/tags/平衡树/" style="font-size: 11.25px;">平衡树</a> <a href="/tags/并查集/" style="font-size: 10px;">并查集</a> <a href="/tags/异或/" style="font-size: 11.25px;">异或</a> <a href="/tags/强制在线/" style="font-size: 10px;">强制在线</a> <a href="/tags/强联通分量/" style="font-size: 10px;">强联通分量</a> <a href="/tags/归并排序/" style="font-size: 10px;">归并排序</a> <a href="/tags/快速幂/" style="font-size: 10px;">快速幂</a> <a href="/tags/打表/" style="font-size: 10px;">打表</a> <a href="/tags/扩展欧几里得/" style="font-size: 10px;">扩展欧几里得</a> <a href="/tags/拆点/" style="font-size: 10px;">拆点</a> <a href="/tags/拓扑排序/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/指针/" style="font-size: 12.5px;">指针</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/搜索/" style="font-size: 16.25px;">搜索</a> <a href="/tags/数学/" style="font-size: 10px;">数学</a> <a href="/tags/数论/" style="font-size: 10px;">数论</a> <a href="/tags/斐波那契博弈/" style="font-size: 10px;">斐波那契博弈</a> <a href="/tags/斐波那契数列/" style="font-size: 10px;">斐波那契数列</a> <a href="/tags/斜率优化/" style="font-size: 11.25px;">斜率优化</a> <a href="/tags/无限/" style="font-size: 10px;">无限</a> <a href="/tags/最大公约数/" style="font-size: 10px;">最大公约数</a> <a href="/tags/最大流/" style="font-size: 10px;">最大流</a> <a href="/tags/最小生成树/" style="font-size: 11.25px;">最小生成树</a> <a href="/tags/最短路/" style="font-size: 16.25px;">最短路</a> <a href="/tags/最长上升子序列/" style="font-size: 11.25px;">最长上升子序列</a> <a href="/tags/最长公共子序列/" style="font-size: 10px;">最长公共子序列</a> <a href="/tags/构造/" style="font-size: 11.25px;">构造</a> <a href="/tags/查分/" style="font-size: 10px;">查分</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/树形dp/" style="font-size: 16.25px;">树形dp</a> <a href="/tags/树状数组/" style="font-size: 11.25px;">树状数组</a> <a href="/tags/模拟/" style="font-size: 17.5px;">模拟</a> <a href="/tags/模板/" style="font-size: 16.25px;">模板</a> <a href="/tags/欧拉函数/" style="font-size: 10px;">欧拉函数</a> <a href="/tags/测试/" style="font-size: 11.25px;">测试</a> <a href="/tags/版权信息/" style="font-size: 10px;">版权信息</a> <a href="/tags/生成树/" style="font-size: 13.75px;">生成树</a> <a href="/tags/矩阵快速幂/" style="font-size: 11.25px;">矩阵快速幂</a> <a href="/tags/秦九韶算法/" style="font-size: 10px;">秦九韶算法</a> <a href="/tags/等差数列/" style="font-size: 10px;">等差数列</a> <a href="/tags/线性代数/" style="font-size: 11.25px;">线性代数</a> <a href="/tags/线段树/" style="font-size: 17.5px;">线段树</a> <a href="/tags/网络流/" style="font-size: 10px;">网络流</a> <a href="/tags/考试/" style="font-size: 10px;">考试</a> <a href="/tags/背包/" style="font-size: 11.25px;">背包</a> <a href="/tags/艺术/" style="font-size: 11.25px;">艺术</a> <a href="/tags/莫比乌斯反演/" style="font-size: 11.25px;">莫比乌斯反演</a> <a href="/tags/规律/" style="font-size: 11.25px;">规律</a> <a href="/tags/解决方案/" style="font-size: 15px;">解决方案</a> <a href="/tags/计划/" style="font-size: 13.75px;">计划</a> <a href="/tags/贪心/" style="font-size: 15px;">贪心</a> <a href="/tags/逆元/" style="font-size: 10px;">逆元</a> <a href="/tags/逆序对/" style="font-size: 10px;">逆序对</a> <a href="/tags/错位排列数/" style="font-size: 10px;">错位排列数</a> <a href="/tags/题目/" style="font-size: 10px;">题目</a> <a href="/tags/高精/" style="font-size: 11.25px;">高精</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/dphigher/">动态规划题目选做</a>
          </li>
        
          <li>
            <a href="/2018/04/10/dpeasypros/">历年NOIP简单动态规划题目选做</a>
          </li>
        
          <li>
            <a href="/2018/04/07/noip2014d2/">NOIP 2014 Day1</a>
          </li>
        
          <li>
            <a href="/2018/04/07/noip2014d1/">NOIP 2014 Day1</a>
          </li>
        
          <li>
            <a href="/2018/04/06/SuffixArray/">后缀数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>