<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Every-SG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/Every-SG/" class="article-date">
  <time datetime="2018-02-27T02:47:51.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/Every-SG/">Every-SG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h3><p>　　关于这个知识也就只有贾志豪的论文有详细的解释了, 但还是看得我一脸懵圈.<br>而且并不存在很多这类题目, 目前只见过一道, 就是本文的例题.</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>　　在一个棋盘上, 有 n 枚棋子, 每次可以向下移动或向右移动, 最后无法移动的人失败, 这就是 Every-SG 的基本模型.<br>　　聪明的读者肯定能想到策略, (<em>然而我不聪明也没有看出这个结论</em>), 对于可以赢的游戏, 一定要拿到这场游戏的胜利.<br>　　所以需要考虑让必胜的游戏尽可能长的玩下去.<br>　　但是对手不希望他必败的单一游戏时间很长.</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>对于没有结束的单一游戏, 游戏者必须对该游戏作出进一步决策.(<em>不明白</em>).</li>
<li>其它规则于普通的(<em>ICG</em>)相同.</li>
</ul>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>　　在通过拓扑关系计算一个状态的 $SG$ 值时, 对于 $SG$ 值不为 0 的点, 我们需要知道最快几步能将游戏带入终止状态, 对于 $SG$ 值, 我们知道最慢几步游戏被带入终止状态, 这个值用 $step$ 表示.<br>$$<br>step(v)=\begin{cases}<br>0,&amp;v\text{ }is\text{ }a\text{ }terminal\text{ }position \\<br>\max{step(u)}+1,&amp;SG(v)&gt;0\text{ }and\text{ }v\rightarrow u\text{ }and\text{ }SG(u)=0\\<br>\min{step(u)}+1,&amp;SG(v)=0\text{ }and\text{ }v\rightarrow u<br>\end{cases}<br>$$</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>　　对于 Every-SG 游戏先手必胜并且仅当单一游戏中最大的 $step$ 为奇数.</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>　　证明解法的正确性, 需要证明三点:</p>
<ul>
<li>对于所有的单一游戏, 先手必胜状态的 $step$ 值为奇数, 后手必胜状态的 $step$ 值为偶数.</li>
<li>设最大的 $step$ 为 $step_ \max$, 胜手可以保证该单一游戏最少会在 $step_ \max$ 步结束.</li>
<li>设最大的 $step$ 为 $step_ \max$, 胜手可以所有他必败游戏最多会在 $step_ \max$ 步结束.</li>
</ul>
<h4 id="证明一"><a href="#证明一" class="headerlink" title="证明一"></a>证明一</h4><ol>
<li>所有的终止状态的 $step$ 值为 $0,为先手必败状态.</li>
<li>假设状态树中某些状态点已经符合要求.我们找后继状态点已经全部被证明的状态点.如果它是先手必败状态，那么它的后继状态都为先手必胜状态,后继状态的 $step$ 值全为奇数，所以该状态点的 $step$ 值为偶数。<br>　　如果它是先手必胜状态，那么它的后继状态中有先手必败状态,且它所有的先手必败的后记状态的 $step$ 值为偶数，所以该状态点的$step$ 值为奇数.</li>
</ol>
<p>$\blacksquare$</p>
<h4 id="证明二"><a href="#证明二" class="headerlink" title="证明二"></a>证明二</h4><p>　　我们设 $step$ 最大的单一游戏为 A（如果有多个的话任取一个） ，最终<br>的胜手为 W.<br>　　W 总在 A 游戏处在先手必胜状态时去移动 A 的状态， 且 W 可以保证他<br>最多将该游戏的 $step$ 值减小 1.$①$<br>　　对手总在 A 游戏处在先手必败状态时去移动 A 的状态，且对手最多<br>将该游戏的 $step$ 值减小 1.$②$<br>　　由$①②$得，J 可以保证 A 游戏最少会在 $\max \text{_} step$ 步结束.<br>$\blacksquare$</p>
<h4 id="证明三"><a href="#证明三" class="headerlink" title="证明三"></a>证明三</h4><p>　　我们设 step 最大的单一游戏为 A(如果有多个的话任取一个),最终的胜手为 W。我们考虑除 A 外的任意一个他必败的单一游戏 B.<br>　　J 在每一回合都可以将 B 的 $step$ 值减少 1，将 B 带入先手必胜状态, 对手必定将 B 的 $step$ 至少减少 1，所以 J 可以保证 B 游戏最多会在 $\max \text{_} step$ 步结束.<br>$\blacksquare$</p>
<h3 id="例题-HDU-3595-GG-and-MM"><a href="#例题-HDU-3595-GG-and-MM" class="headerlink" title="例题: HDU 3595 GG and MM"></a>例题: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3595" target="_blank" rel="external">HDU 3595 GG and MM</a></h3><h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>　　GG and MM like playing a game since they are children. At the beginning of game, there are two piles of stones. MM chooses a pile of stones first, which has x stones, and then she can choose a positive number k and remove k<em>x stones out from the other pile of stones, which has y stones (I think all of you know that y&gt;=k</em>x - -!). Then it comes the turn of GG, followed the rules above-mentioned as well. When someone can’t remove any stone, then he/she loses the game, and this game is finished.<br>　　Many years later, GG and MM find this game is too simple, so they decided to play N games at one time for fun. MM plays first, as the same, and the one on his/her turn must play every unfinished game. Rules to remove are as same as above, and if someone cannot remove any stone (i.e., loses the last ending game), then he/she loses. Of course we can assume GG and MM are clever enough, and GG will not lose intentionally, O(∩_∩)O~</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>　　The input file contains multiply test cases (no more than 100).<br>The first line of each test case is an integer N, N&lt;=1000, which represents there are N games, then N lines following, each line has two numbers: p and q, standing for the number of the two piles of stones of each game, p, q&lt;=1000(it seems that they are so leisure = =!), which represent the numbers of two piles of stones of every game.<br>　　The input will end with EOF.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>　　For each test case, output the name of the winner.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>3<br>1 1<br>1 1<br>1 1<br>1<br>3 2</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>MM<br>GG</p>
<p>Author<br>alpc95<br>Source<br>2010 ACM-ICPC Multi-University Training Contest（16）——Host by NUDT<br>Recommend<br>zhengfeng</p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h4><p>　　游戏共有 $n$ 个子游戏, 每个子游戏有两堆石子, 每次没人可以从较大的一堆中拿出较小一堆的数量的倍数, 最后无法操作的人失败.</p>
<h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>　　通过观察我们发现这道题目胜负在于持续时间最长的那场子游戏. 所以这是一个$Every-SG$游戏, 应用他的基本做法即可.<br>　　有一个比较特殊的性质需要注意, 如果一场子游戏为$(x,y)$, 那么当$\frac{x}{y}&gt;1$时, 这场游戏先手必胜, 因为他可以通过倍数来控制接下来步数的奇偶性.</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))ch=getchar();</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> a[N],b[N],SG[N][N],step[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSG</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(x&gt;y) <span class="built_in">std</span>::swap(x,y);</div><div class="line">    <span class="keyword">if</span>(SG[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> SG[x][y];</div><div class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> SG[x][y]=step[x][y]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> willx=y%x,willy=x;</div><div class="line">    <span class="keyword">int</span> k=y/x;</div><div class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</div><div class="line">        SG[x][y]=GetSG(willx,willy)^<span class="number">1</span>;</div><div class="line">        step[x][y]=step[willx][willy]+<span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> SG[x][y];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        step[x][y]=GetSG(willx,willy)+step[willx][willy]+<span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> SG[x][y]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(SG,<span class="number">-1</span>,<span class="keyword">sizeof</span>(SG));</div><div class="line">    <span class="keyword">int</span> n,x,y,ans;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</div><div class="line">        ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++) </div><div class="line">            x=read(),y=read();</div><div class="line">            <span class="keyword">if</span>(x&gt;y)swap(x,y);</div><div class="line">            GetSG(x,y);</div><div class="line">            ans=max(ans,step[x][y]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">puts</span>(ans&amp;<span class="number">1</span>?<span class="string">"MM"</span>:<span class="string">"GG"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/Every-SG/" data-id="cjftq8nti0004e0kel4x9c7xt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Every-SG/">Every-SG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Multi-SG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/26/Multi-SG/" class="article-date">
  <time datetime="2018-02-26T03:12:19.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/Multi-SG/">Multi-SG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h3><p>　　对于 Multi SG 这个名称我依然比较疑惑, 为什么要这么叫呢?大概是我太较真了.<br>　　不知道为啥, 关于 Multi-SG 的题目虽然不少, 但是都涉及到其它的一些东西, 所以偏难,因为这个东西理论上没什么可以讲的, 所以本文主要讲题.<br>　　下面这道题实际上是 Lasker’s Nim. A special Nim.</p>
<h3 id="HDU-3032-Nim-or-not-Nim"><a href="#HDU-3032-Nim-or-not-Nim" class="headerlink" title="HDU 3032 Nim or not Nim?"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3032" target="_blank" rel="external">HDU 3032 Nim or not Nim?</a></h3><h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>　　Nim is a two-player mathematic game of strategy in which players take turns removing objects from distinct heaps. On each turn, a player must remove at least one object, and may remove any number of objects provided they all come from the same heap.</p>
<p>　　Nim is usually played as a misere game, in which the player to take the last object loses. Nim can also be played as a normal play game, which means that the person who makes the last move (i.e., who takes the last object) wins. This is called normal play because most games follow this convention, even though Nim usually does not.</p>
<p>　　Alice and Bob is tired of playing Nim under the standard rule, so they make a difference by also allowing the player to separate one of the heaps into two smaller ones. That is, each turn the player may either remove any number of objects from a heap or separate a heap into two smaller ones, and the one who takes the last object wins.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>　　Input contains multiple test cases. The first line is an integer 1 ≤ T ≤ 100, the number of test cases. Each case begins with an integer N, indicating the number of the heaps, the next line contains N integers s[0], s[1], …., s[N-1], representing heaps with s[0], s[1], …, s[N-1] objects respectively.(1 ≤ N ≤ 10^6, 1 ≤ S[i] ≤ 2^31 - 1)</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>　　For each test case, output a line which contains either “Alice” or “Bob”, which is the winner of this game. Alice will play first. You may asume they never make mistakes.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>2<br>3<br>2 2 3<br>2<br>3 3</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>Alice<br>Bob</p>
<h4 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h4><p>　　好了让我们忽略那写奇怪的大的吓人的数据范围, 只要想出一种可行的方案就可以.<br>　　其实非常好想是吧, 根本一点思考都不需要.如果在一个操作中将有 $n$ 堆石子的局面 $i$ 变成了 有 $n+1$ 堆的局面 $i’$, 那么 $SG(i’)$ 相比于 $SG(i)$ 发生的变化只不过是:<br>$$SG(i)=SG(1)\oplus SG(2)\oplus \cdots \oplus SG(n)\longrightarrow \ SG(i’)=SG(1)\oplus SG(2)\oplus \cdots \oplus SG(n+1)$$<br>　　它实际上并没有发生什么实质性的变化对吧.最大的不同是它不能像 Normal Nim 一样有那么简洁的做法.它需要递推 SG 函数, 所以可以给出一段可以做这件事情的代码.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> sg[N];</div><div class="line"><span class="keyword">int</span> stone;</div><div class="line"><span class="keyword">int</span> append[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</div><div class="line">		<span class="built_in">memset</span>(append,<span class="literal">false</span>,<span class="keyword">sizeof</span>(append));</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;++i)</div><div class="line">			append[sg[i]]=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;j;++i)</div><div class="line">			append[sg[i]^sg[j-i]]=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;++i)</div><div class="line">			<span class="keyword">if</span>(!append[i])&#123;</div><div class="line">				sg[j]=i;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;stone;</div><div class="line">		ans^=sg[stone];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ans)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Alice\n"</span>);</div><div class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Bob\n"</span>);	</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　但是很遗憾, 它不能通过这道题目.但是它可以很好的作为一个打表的程序帮助我们发现规律.(一脸黑线).而且关于下面的规律实在是找不到一个证明, 估计不是很好证明.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">sg(0)=  0</div><div class="line">sg(1)=  1</div><div class="line">sg(2)=  2</div><div class="line">sg(3)=  4</div><div class="line">sg(4)=  3</div><div class="line">sg(5)=  5</div><div class="line">sg(6)=  6</div><div class="line">sg(7)=  8</div><div class="line">sg(8)=  7</div><div class="line">sg(9)=  9</div><div class="line">sg(10)= 10</div><div class="line">sg(11)= 12</div><div class="line">sg(12)= 11</div><div class="line">sg(13)= 13</div><div class="line">sg(14)= 14</div><div class="line">sg(15)= 16</div><div class="line">sg(16)= 15</div><div class="line">sg(17)= 17</div><div class="line">sg(18)= 18</div><div class="line">sg(19)= 20</div><div class="line">sg(20)= 19</div><div class="line">sg(21)= 21</div><div class="line">sg(22)= 22</div><div class="line">sg(23)= 24</div><div class="line">sg(24)= 23</div><div class="line">sg(25)= 25</div><div class="line">sg(26)= 26</div><div class="line">sg(27)= 28</div><div class="line">sg(28)= 27</div><div class="line">sg(29)= 29</div><div class="line">sg(30)= 30</div><div class="line">sg(31)= 32</div><div class="line">sg(32)= 31</div><div class="line">sg(33)= 33</div><div class="line">sg(34)= 34</div><div class="line">sg(35)= 36</div><div class="line">sg(36)= 35</div><div class="line">sg(37)= 37</div><div class="line">sg(38)= 38</div><div class="line">sg(39)= 40</div><div class="line">sg(40)= 39</div><div class="line">sg(41)= 41</div><div class="line">sg(42)= 42</div><div class="line">sg(43)= 44</div><div class="line">sg(44)= 43</div><div class="line">sg(45)= 45</div><div class="line">sg(46)= 46</div><div class="line">sg(47)= 48</div><div class="line">sg(48)= 47</div><div class="line">sg(49)= 49</div><div class="line">sg(50)= 50</div></pre></td></tr></table></figure></p>
<p>　　这是 1-100 的SG函数, 我们可以明显的发现一个事实, $|i-sg(i)|\leq 2$.更进一步, 如果我们将 $i-sg(i)$ 看作 $f(i)$, 那么 $f(i)$ 在 前50个数的取值为:<br>　　我们很容易可以发现, 它以 -1,0,0,1 为最小循环节, 那么这道题目就可以轻松解决了.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,T;</div><div class="line"><span class="keyword">int</span> sg[N];</div><div class="line"><span class="keyword">int</span> stone;</div><div class="line"><span class="keyword">int</span> table[N]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">	<span class="keyword">while</span>(T--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;stone;</div><div class="line">			ans^=stone+table[stone%<span class="number">4</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ans)<span class="built_in">printf</span>(<span class="string">"Alice\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Bob\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="POJ-2311-Cutting-Game"><a href="#POJ-2311-Cutting-Game" class="headerlink" title="POJ 2311 Cutting Game"></a><a href="http://poj.org/problem?id=2311" target="_blank" rel="external">POJ 2311 Cutting Game</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>　　Urej loves to play various types of dull games. He usually asks other people to play with him. He says that playing those games can show his extraordinary wit. Recently Urej takes a great interest in a new game, and Erif Nezorf becomes the victim. To get away from suffering playing such a dull game, Erif Nezorf requests your help. The game uses a rectangular paper that consists of W*H grids. Two players cut the paper into two pieces of rectangular sections in turn. In each turn the player can cut either horizontally or vertically, keeping every grids unbroken. After N turns the paper will be broken into N+1 pieces, and in the later turn the players can choose any piece to cut. If one player cuts out a piece of paper with a single grid, he wins the game. If these two people are both quite clear, you should write a problem to tell whether the one who cut first can win or not.</p>
<h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>　　The input contains multiple test cases. Each test case contains only two integers W and H (2 &lt;= W, H &lt;= 200) in one line, which are the width and height of the original paper.</p>
<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><p>　　For each test case, only one line should be printed. If the one who cut first can win the game, print “WIN”, otherwise, print “LOSE”.</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>2 2<br>3 2<br>4 2</p>
<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>LOSE<br>LOSE<br>WIN</p>
<h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法:"></a>做法:</h4><p>　　这道题目相对于上一道题目并没有什么不一样的地方, 唯一是它的状态是以两维表示的, 比如说一个 $a\times b$ 的纸片, 而上一道题是一堆 $m$ 个石子.所以这一道题和上一道题的做法一样, 只需要求出所有可能的子游戏的 SG 函数, 游戏的 SG 值就是这些子游戏 SG 值的异或和.<br>　　Tips: 题目说当游戏说出现了 $1\times 1$ 的纸片时结束, 也就是说$1\times $<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 205</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,T;</div><div class="line"><span class="keyword">int</span> Set[N];</div><div class="line"><span class="keyword">int</span> sg[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;++i)</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">200</span>;++j)&#123;</div><div class="line">		<span class="built_in">memset</span>(Set,<span class="number">0</span>,<span class="keyword">sizeof</span>(Set));</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=i<span class="number">-2</span>;++k)</div><div class="line">			Set[sg[k][j]^sg[i-k][j]]=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=j<span class="number">-2</span>;++k)</div><div class="line">			Set[sg[i][k]^sg[i][j-k]]=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;;++k)</div><div class="line">			<span class="keyword">if</span>(!Set[k])&#123;</div><div class="line">				sg[i][j]=k;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> n,m;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(sg[n][m])</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"WIN\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"LOSE\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="POJ-3537-BZOJ-2940"><a href="#POJ-3537-BZOJ-2940" class="headerlink" title="POJ 3537/BZOJ 2940"></a>POJ 3537/BZOJ 2940</h3><p>　　对于这两道题目, 我们都可以抽象出这么一个模型, 给出 n 个石子, 将其中一些连续的拿走, 最后无法继续行动游戏结束.<br>　　所以这道题大概是比上面那一道题目还要简单一些, 只需要递推一维状态.但是成功从题面中提取出问题的模型还是一个非常重要的能力.<br>　　但是有些细节方面还需要斟酌.所以这两道题目可以当成是练习题.</p>
<h3 id="BZOJ-1188-HNOI2007-分裂游戏"><a href="#BZOJ-1188-HNOI2007-分裂游戏" class="headerlink" title="BZOJ 1188 [HNOI2007] 分裂游戏"></a>BZOJ 1188 [HNOI2007] 分裂游戏</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>　　聪聪和睿睿最近迷上了一款叫做分裂的游戏。该游戏的规则试：共有n个瓶子，标号为0,1,2…..n-1,第i个瓶子中装有p[i]颗巧克力豆，两个人轮流取豆子，每一轮每人选择3个瓶子。标号为i,j,k,并要保证i&lt;j,j&lt;=k且第i个瓶子中至少要有1颗巧克力豆，随后这个人从第i个瓶子中拿走一颗豆子并在j,k中各放入一粒豆子（j可能等于k）。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？假定 1 &lt; n &lt; = 21,p[i] &lt; = 10000</p>
<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><p>　　输入文件第一行是一个整数t表示测试数据的组数，接下来为t组测试数据（t&lt;=10）。每组测试数据的第一行是瓶子的个数n，接下来的一行有n个由空格隔开的非负整数，表示每个瓶子中的豆子数。</p>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><p>　　对于每组测试数据，输出包括两行，第一行为用一个空格两两隔开的三个整数，表示要想赢得游戏，第一步应该选取的3个瓶子的编号i,j,k，如果有多组符合要求的解，那么输出字典序最小的一组。如果无论如何都无法赢得游戏，那么输出用一个空格两两隔开的三个-1。第二行表示要想确保赢得比赛，第一步有多少种不同的取法。</p>
<h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>2<br>4<br>1 0 1 5000<br>3<br>0 0 1</p>
<h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>0 2 3<br>1<br>-1 -1 -1<br>0</p>
<h4 id="做法-2"><a href="#做法-2" class="headerlink" title="做法:"></a>做法:</h4><p>　　这道题目和前面几道题目难度要高.但是仍然是 Multi-SG 的基本应用, 难度在于分析于建模.<br>　　我们可以观察出这样的性质, 如果当前位置有偶数个豆子, 那么一个人总能抵消掉一个人的的操作, 因此我们只需要考虑个数为奇数的即可.而且完全可以将奇数个看成1个, 所以序列就变成了01串.<br>　　接下来用 Multi-SG 的方法做就可以了, 最后输出方案就见仁见智了.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n,S[N],SG[N];</div><div class="line"><span class="keyword">int</span> a[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(SG[now]!=<span class="number">-1</span>) <span class="keyword">return</span> SG[now];</div><div class="line">    <span class="built_in">memset</span>(S,<span class="number">0</span>,<span class="keyword">sizeof</span>(S));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=now+<span class="number">1</span>;i&lt;=N;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=N;j++)</div><div class="line">            S[ (dfs(i)^dfs(j)) ] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++) <span class="keyword">if</span>(!S[i]) &#123;SG[now]=i;<span class="keyword">break</span>;&#125;</div><div class="line">    <span class="keyword">return</span> SG[now];</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">    <span class="keyword">while</span>(T--)&#123;</div><div class="line">        <span class="built_in">memset</span>(SG,<span class="number">-1</span>,<span class="keyword">sizeof</span>(SG));</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) a[i]=read();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) </div><div class="line">                <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) dfs(i);    </div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,tot=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)ans=(ans^dfs(i));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=N;j++)</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=N;k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>( (ans^dfs(i)^dfs(j)^dfs(k) )!=<span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                    tot++;</div><div class="line">                    <span class="keyword">if</span>(tot==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,i<span class="number">-1</span>,j<span class="number">-1</span>,k<span class="number">-1</span>);</div><div class="line">                &#125;</div><div class="line">        <span class="keyword">if</span>(tot==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1 -1 -1\n"</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Luogu-P3235-HNOI2014-江南乐"><a href="#Luogu-P3235-HNOI2014-江南乐" class="headerlink" title="Luogu P3235 [HNOI2014]江南乐"></a><a href="https://www.luogu.org/problemnew/show/P3235" target="_blank" rel="external">Luogu P3235 [HNOI2014]江南乐</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　小A是一个名副其实的狂热的回合制游戏玩家。在获得了许多回合制游戏的世界级奖项之后，小A有一天突然想起了他小时候在江南玩过的一个回合制游戏。</p>
<p>　　游戏的规则是这样的，首先给定一个数F，然后游戏系统会产生T组游戏。每一组游戏包含N堆石子，小A和他的对手轮流操作。每次操作时，操作者先选定一个不小于2的正整数M (M是操作者自行选定的，而且每次操作时可不一样)，然后将任意一堆数量不小于F的石子分成M堆，并且满足这M堆石子中石子数最多的一堆至多比石子数最少的一堆多1（即分的尽量平均，事实上按照这样的分石子万法，选定M和一堆石子后，它分出来的状态是固定的）。当一个玩家不能操作的时候，也就是当每一堆石子的数量都严格小于F时，他就输掉。(补充：先手从N堆石子中选择一堆数量不小于F的石子分成M堆后，此时共有N+M-1)堆石子，接下来小A从这N+M-1堆石子中选择一堆数量不小于F的石子，依此类推。</p>
<p>　　小A从小就是个有风度的男生，他邀请他的对手作为先手。小A现在想要知道，面对给定的一组游戏，而且他的对手也和他一样聪明绝顶的话，究竟谁能够获得胜利？</p>
<h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h5><p>　　输入第一行包含两个正整数T和F，分别表示游戏组数与给定的数。 接下来T行，每行第一个数N表示该组游戏初始状态下有多少堆石子。之后N个正整数，表示这N堆石子分别有多少个。</p>
<h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>　　输出一行，包含T个用空格隔开的0或1的数，其中0代表此时小A（后手）会胜利，而1代表小A的对手（先手）会胜利。</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h5><p>4 3<br>1 1<br>1 2<br>1 3<br>1 5</p>
<h5 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h5><p>0 0 1 1</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>对于100%的数据，T&lt;100，N&lt;100，F&lt;100000，每堆石子数量&lt;100000。<br>以上所有数均为正整数。</p>
<h4 id="做法-3"><a href="#做法-3" class="headerlink" title="做法:"></a>做法:</h4><p>　　这道题目的题意是, 给出 n 堆石子, 每次可以选择将大于某个数一堆平均分成多个堆, 最后不能操作的失败.<br>　　根据我们处理这类题目的一般思路, 先求出每一堆石子也就是每一个子游戏的 $SG$ 值, 然后异或起来求出游戏的 $SG$ 值.<br>　　分析这道题可以发现, 如果将数量为 $m$ 的一堆划分成 $i$ 堆, 那么将会划分出 $\lfloor \frac{x}{i}\rfloor\times i$ 堆个数为 $\lfloor\frac{m}{i}\rfloor$ 的堆, 和 $m-\lfloor\frac{m}{i}\rfloor\times i$ 堆个数为 $\lfloor\frac{m}{i}\rfloor+1$ 的堆.<br>　　这样我们一个常规的思路是枚举 $i$, 求出划分成 $i$ 堆的 $SG$ 函数.然后求解 $SG(m)$.然而这样效率会很低, 于是需要简化这个过程.<br>　　观察到如果一种划分方案为 $j,j,j,\cdots ,j+1,j+1,\cdots $, 那么在异或的过程中 $SG(j)\oplus SG(j)=0,SG(j+1)\oplus SG(j+1)=0$, 于是在这个过程中起关键作用的是 $j$ 和 $j+1$ 的个数是否为奇数, 如果是奇数它将会对答案产生 $SG(j)$ 或 $SG(j+1)$ 的贡献.<br>　　但是这样还是不够的, 我们自然而然的想到, 如果将石子堆划分为 $i$ 堆 或者是 $k$ 堆而且 $\lfloor\frac{m}{i}\rfloor=\lfloor\frac{m}{k}\rfloor$ , 它们的后继状态都是 $SG(\lfloor\frac{m}{i}\rfloor)$ 或者是 $SG(\lfloor\frac{m}{i}\rfloor+1)$, 它们对答案的贡献可能是相同的, 根据上一段的论述, 这取决于 $m-\lfloor\frac{m}{i}\rfloor\times i$ 和 $\lfloor \frac{x}{i}\rfloor\times i$ 的奇偶性. 如果我们手推一下, 就会发现如果<br>$$\lfloor\frac{m}{i}\rfloor=\lfloor\frac{m}{i+1}\rfloor=\lfloor\frac{m}{i+2}\rfloor=\cdots $$,<br>　　那么 $i$ 和 $i+1$ 对答案的贡献是相同的, $i+1$ 和 $i+2$ 堆答案的贡献相同, 相同的状态我们只需要计算一次, 对于$\frac{m}{i}$相同的所有 $i$, 我们只需要计算最小的 $i$ 和 $i+1$ 即可.<br>　　问题又来了, 我们如何跳过 $i+2,i+3,\cdots$ 呢? 如果你数学学的不错或者是做过莫比乌斯反演, 就会知道一个常用技巧, $m/(m/i)$ 是 $\frac{m}{i}$ 值相同的 $i$ 的最大值. </p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><h5 id="The-Normal"><a href="#The-Normal" class="headerlink" title="The Normal"></a>The Normal</h5><p>　　虽然通过此题但是几乎到了时间上限, 缺点是需要大量的开栈空间和初始化数组, 效率非常低.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> ch=getchar();</div><div class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">    <span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> sg[N];</div><div class="line"><span class="keyword">int</span> f;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(sg[x]&gt;<span class="number">-1</span>)<span class="keyword">return</span> sg[x];</div><div class="line">    <span class="keyword">if</span>(x&lt;f)<span class="keyword">return</span> sg[x]=<span class="number">0</span>;</div><div class="line">    sg[x]=<span class="number">0</span>;<span class="keyword">int</span> ans;</div><div class="line">    <span class="keyword">int</span> s[N];</div><div class="line">    <span class="built_in">memset</span>(s,<span class="literal">false</span>,<span class="keyword">sizeof</span>(s));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i=x/(x/i)+<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=min(i+<span class="number">1</span>,x);++j)&#123;</div><div class="line">            ans=<span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>((x%j)&amp;<span class="number">1</span>)</div><div class="line">                ans^=find(x/j+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>((j-x%j)&amp;<span class="number">1</span>)</div><div class="line">                ans^=find(x/j);</div><div class="line">            s[ans]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)</div><div class="line">        <span class="keyword">if</span>(!s[i])&#123;</div><div class="line">            sg[x]=i;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;T&gt;&gt;f;</div><div class="line">    <span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sg));</div><div class="line">    <span class="keyword">while</span>(T--)&#123;</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n,get;</div><div class="line">        n=read();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</div><div class="line">            ans^=find(read());</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans?<span class="number">1</span>:<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="The-Better"><a href="#The-Better" class="headerlink" title="The Better"></a>The Better</h6><p>　　将上述代码中的<code>find()</code>替换成下述代码.<br>　　用到了一个比较巧妙的思路避免了上述问题, 效率提高了至少三倍.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(sg[x]&gt;<span class="number">-1</span>)<span class="keyword">return</span> sg[x];</div><div class="line">    <span class="keyword">if</span>(x&lt;f)<span class="keyword">return</span> sg[x]=<span class="number">0</span>;</div><div class="line">    sg[x]=<span class="number">0</span>;<span class="keyword">int</span> ans;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i=x/(x/i)+<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=min(i+<span class="number">1</span>,x);++j)&#123;</div><div class="line">            ans=<span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>((x%j)&amp;<span class="number">1</span>)</div><div class="line">                ans^=find(x/j+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>((j-x%j)&amp;<span class="number">1</span>)</div><div class="line">                ans^=find(x/j);</div><div class="line">            s[ans]=x;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">while</span>(s[sg[x]]==x)sg[x]++;</div><div class="line">    <span class="keyword">return</span> sg[x];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/26/Multi-SG/" data-id="cjftq8nts000ce0keu3ebudkc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lasker-s-Nim/">Lasker's Nim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Multi-SG/">Multi-SG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Anti-SG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/26/Anti-SG/" class="article-date">
  <time datetime="2018-02-26T00:17:21.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/Anti-SG/">Anti-SG/Misère Games</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h3><p>　　其实一直没搞明白为什么这个东西叫 Anti-SG , 感觉更应该叫 Misère Games/ICG$_{1}$, 这个 Anti-SG 大概是基于 <strong>Misère play rule</strong> 提出来的, <em>就像 Misère 的 Nim 版本叫 Misère Nim</em>. 可是我除了在 <strong>2009 年的贾志豪的论文之外</strong> 没有见过这个名词, <em>其它涉及到这个词的都是基于此</em>. 但是既然有人这么叫, 那就这么叫吧.</p>
<ul>
<li>可以参考<a href="http://www.ams.org/publicoutreach/feature-column/fcarc-games4" target="_blank" rel="external">http://www.ams.org/publicoutreach/feature-column/fcarc-games4</a></li>
<li>关于 Misère Games 的更多可以看<a href="http://miseregames.org/" target="_blank" rel="external">http://miseregames.org/</a>.</li>
<li><p>关于 Misère Games 的一篇非常详细的<a href="https://arxiv.org/pdf/math/0612616.pdf" target="_blank" rel="external">论文</a>.</p>
</li>
<li><p>本文的最后有脚注, 如果看到某些不应该有下标小数字的地方, 请看文章底的<strong>脚注</strong></p>
</li>
<li>估计如果真的在提高或者省选出一道真正的 <strong>Misère Games</strong>, 会引起一场腥风血雨.</li>
<li>当然本文在 SJ定理 证明的地方留下了空白, 日后补充.</li>
</ul>
<h3 id="Misere-Nim-Anti-nim"><a href="#Misere-Nim-Anti-nim" class="headerlink" title="Misère Nim/Anti-nim"></a>Misère Nim/Anti-nim</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>　　贾老师将其称为 “Anti-nim”.<br>　　Misère Nim 的游戏规则大概是, 有很多堆石子, 两个人依次行动, 每次可以从任意一堆中拿出任意个石子, 先拿完所有石子的人获胜.</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>　　大概是 Bouton 提出了玩 Misère Nim 的方法.它基本上是这么描述的.</p>
<ul>
<li>结论一: 当堆不全是个数为1的堆的时候, 胜负情况和 Normal Nim 一致.</li>
<li>结论二: 当堆里全是个数为1的堆的时候, 当堆数为偶数时先手必胜.</li>
</ul>
<h4 id="对于结论的说明"><a href="#对于结论的说明" class="headerlink" title="对于结论的说明"></a>对于结论的说明</h4><ul>
<li>首先<strong>结论二</strong>显然, 每次每人取一堆, 必定是后手取到最后一堆.</li>
<li>《Game Theory》 上对于<strong>结论一</strong>的解释大概是, 在 <strong>Normal Nim</strong> 中, 你不能使在你的回合结束后只剩下恰好一堆大于 1 的石子(这样 nim-sum 不为0). 在先手的回合后 nim-sum 为 0 ,这意味这必然存在至少两堆大于1的石子, 然而后手不能将两堆大于1的石子变成都小于等于1, 所以最终游戏在先手的回合会进入一个只有一堆石子数大于1的局面.  仔细体会一下.</li>
<li>为什么只有一堆石子大于1先手必胜呢? 因为先手可以通过操作这堆大于1的石子将局面变成奇数个1.</li>
</ul>
<h3 id="Anti-SG-与-SJ-定理"><a href="#Anti-SG-与-SJ-定理" class="headerlink" title="Anti-SG 与 SJ 定理"></a><em>Anti-SG</em> 与 <em>SJ 定理</em></h3><p>　　<em>下面引用了贾志豪的论文</em><br>　　我们先给出 Anti-SG 游戏的定义：</p>
<h4 id="Anti-SG-定义"><a href="#Anti-SG-定义" class="headerlink" title="Anti-SG 定义"></a>Anti-SG 定义</h4><ul>
<li>Anti-SG 游戏规定，决策集合为空的游戏者赢.</li>
<li>Anti-SG 其他规则与 SG 游戏相同.</li>
</ul>
<h4 id="SJ-定理"><a href="#SJ-定理" class="headerlink" title="SJ 定理"></a>SJ 定理</h4><p>　　SJ 定理的全称是 “Sprague Grundy——Jia Zhihao 定理$_{2}$” .<br>　　对于任意一个 Anti-SG游戏, 如果我们规定当局面中所有的单一游戏的 SG 值为 0 时, 游戏结束, 则先手必胜当且仅当： (1)游戏的 SG 函数不为 0 且游戏中某个单一游戏的 SG 函数大于 1 ; (2)游戏的 SG 函数为 0 且游戏中没有单一游戏的 SG 函数大于 1.</p>
<h4 id="SJ-定理证明"><a href="#SJ-定理证明" class="headerlink" title="SJ 定理证明"></a>SJ 定理证明</h4><p>此处先留坑</p>
<h4 id="Bzoj-1022-SHOI2008-小约翰的游戏John"><a href="#Bzoj-1022-SHOI2008-小约翰的游戏John" class="headerlink" title="Bzoj 1022: [SHOI2008]小约翰的游戏John"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1022" target="_blank" rel="external">Bzoj 1022: [SHOI2008]小约翰的游戏John</a></h4><p>　　貌似目前为止出现过的有关 Anti-SG 的题目只有一个, 而且还是 Anti-nim.</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>这是根据做法直接写出来的代码, 实际上还能写的更简洁.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">	<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">	<span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> T,n;</div><div class="line"><span class="keyword">int</span> sum1,sum2;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">	<span class="keyword">int</span> ccin;</div><div class="line">	<span class="keyword">while</span>(T--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;n;sum2=sum1=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">			ccin=read();</div><div class="line">			sum1^=ccin;</div><div class="line">			<span class="keyword">if</span>(ccin&gt;<span class="number">1</span>)sum2=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(sum2)&#123;</div><div class="line">			<span class="keyword">if</span>(sum1!=<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"John\n"</span>);</div><div class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Brother\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!sum2&amp;&amp;n%<span class="number">2</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"John\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Brother\n"</span>);</div><div class="line">	&#125;	</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ol>
<li>本文的所有的 <strong><em>Misère</em></strong> 其实是<img src="\myjson\Png3.png" alt="Png1">.大概是法语.</li>
<li>贾老师还真是幽默啊, 不过这个定理在各大博客的出镜率还真的是不低.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/26/Anti-SG/" data-id="cjftq8nym008xe0keni9li221" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Anti-SG/">Anti-SG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Misere-Games/">Misère Games</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-weizuofuth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/weizuofuth/" class="article-date">
  <time datetime="2018-02-25T13:24:22.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/weizuofuth/">威佐夫博弈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="51nod-1072-威佐夫游戏"><a href="#51nod-1072-威佐夫游戏" class="headerlink" title="51nod 1072 威佐夫游戏"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1072" target="_blank" rel="external">51nod 1072 威佐夫游戏</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。<br>例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>　　第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p>3<br>3 5<br>3 4<br>1 9</p>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p>B<br>A<br>A</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>　　题目都说来这是一个威佐夫游戏, 那自然就是一个威佐夫游戏.正好我也没接触过威佐夫游戏题, 正好来接触一下.<br>关于此题的证明<a href="http://blog.sina.com.cn/s/blog_a661ecd501017out.html" target="_blank" rel="external">1</a>或者<a href="https://baike.baidu.com/item/%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88/19858256?fr=aladdin" target="_blank" rel="external">2</a>.<br>不过最精彩的还是 <strong>Matrix67</strong> 作出的(证明)[<a href="http://www.matrix67.com/blog/archives/6784" target="_blank" rel="external">http://www.matrix67.com/blog/archives/6784</a>]</p>
<h4 id="奇异局势"><a href="#奇异局势" class="headerlink" title="奇异局势"></a>奇异局势</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　如果此时局势是奇异局势, 那么此时操作的人将必败.$(0,0)$是奇异局势, 下面几个奇异局势分别为$(1,2), (3,5), (4,7), (6,10), (8,13), (9,15)$.<br>　　用$(a_i,b_i)$表示奇异局势, 那么它可以这么表示:</p>
<ul>
<li>$a_0=0$,$b_0=0$</li>
<li>$a_i$是从未在之前的$a_k,b_k (0\leq k\leq i-1) $中出现过的最小自然数, $b_i=a_i+i$</li>
</ul>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>1.任何自然数都包含在一个且仅有一个奇异局势中.<br>由于$a_k$是从未在前面出现过的最小自然数, 所以$a_k&gt;a_{k-1}$, 而$b_k=a_k+k&gt;a_{k-1}$.<br>2.任意操作都可将奇异局势变为非奇异局势.</p>
<ul>
<li>如果只改变$(a_i,b_i)$中的一个, 根据上述结论, 奇异局势一定被改变;</li>
<li>如果同时改变$(a_i,b_i)$为$(a_i-k,b_i-k)$, 因为$a_j+j=b_j$, 所以两者的差被改变,奇异局势被改变.</li>
<li>采取一定办法可以将非奇异局势转变为奇异局势.假设当前局势为$(a,b)$.<br>1.若$b=a$, 则同时从堆中取走 $a$ 个物品, 就变成来奇异局势;<br>2.若$\exists a_k=a$且$b&gt;b_k$, 则从$b$中取出$b_k-b$个即可;<br>3.若$\exists a_k=a$且$b&lt; b_k$, 则同时从两堆中拿走$a-a_{b-a}$个即可变成$(a_{b-a},a_{b-a}+b-a)$;<br>4.若$\exists b_k=b$且$a&gt;a_k$, 则从 $a$ 中拿出 $a-a_k$即可;<br>5.若$\exists b_k=b$且$a&lt; a_k$, 若$a=a_j or b_j$则从$b$中拿出$b-b_j$或$b-a_j$即可.<h4 id="Beatty-定理"><a href="#Beatty-定理" class="headerlink" title="Beatty 定理"></a>Beatty 定理</h4>　　这部分内容来自 Matrix67 的博客.<br>　　如果正无理数 $\alpha$ 和$ \beta$ 满足 $\frac{1}{\alpha}+\frac{1}{\beta}=1$, 则数列$\lfloor \alpha,2\dot \alpha,\cdots\rfloor$ 和 $\lfloor \beta,2\dot \alpha,\cdots $既无遗漏又不重复的包含了所有的正整数.</li>
</ul>
<p>**<br>　　首先注意到，如果 x 和 y 都不是整数，那么 [x] 严格地小于 x ，[y] 严格地小于 y ，从而 [x] + [y] &lt; x + y 。另外，[x] 一定严格地大于 x – 1 ， [y] 一定严格地大于 y – 1 ，从而 [x] + [y] 一定严格地大于 x + y – 2。这说明，当 x 和 y 都不是整数时， [x] + [y] 将介于 x + y – 2 和 x + y 之间。</p>
<p>　　回到原问题。显然，在数列 [1 · α], [2 · α], [3 · α], … 中，小于 n 的正整数有 [n / α] 个。显然，在数列 [1 · β], [2 · β], [3 · β], … 中，小于 n 的正整数有 [n / β] 个。因此，在这两个数列中，小于 n 的正整数共有 [n / α] + [n / β] 个。由于 α 和 β 都是无理数，因此 n / α 和 n / β 不可能为整数，由刚才的结论， [n / α] + [n / β] 一定介于 n / α + n / β – 2 和 n / α + n / β 之间，即 n – 2 和 n 之间。但是， [n / α] + [n / β] 是个整数，因而它精确地等于 n – 1 。</p>
<p>　　这说明，前 n – 1 个正整数在两个数列中一共出现了 n – 1 次，这对于所有 n 都成立。于是，正整数 1 必须且只能出现在其中一个数列中，正整数 2 必须且只能出现在其中一个数列中，以此类推，每一个新的正整数都必须且只能出现在其中一个数列中。</p>
<p>　　序列 W 的性质 2 则是， W 当中各项里的两数之差依次为 1, 2, 3, … ，也就是说第 n 个数对里的两数之差恰好为 n 。这一点也是很容易看出来的。由于 φ 满足 1 + φ = φ2 ，因而 n + n · φ = n · φ2 ，即 n · φ 和 n · φ2 正好相差 n 。如果两个数正好相差 n ，那么这两个数的整数部分显然也就正好相差 n 。这就证明了序列 W 满足性质 2 。</p>
<p>　　序列 W 的性质 3 则是， W 当中各项里的较小数依次递增，即 [1·φ], [2·φ], [3·φ], … 依次递增。这就更显然了：在数列 1·φ, 2·φ, 3·φ, … 中，后一项总比前一项大 φ ≈ 1.618 &gt; 1 ，因此即使取整后，后一项也一定严格地大于前一项。注意到，性质 2 和性质 3 结合起来可以告诉我们， W 当中各项里的较大数也是依次递增的。<br>**</p>
<h4 id="详细证明"><a href="#详细证明" class="headerlink" title="详细证明"></a>详细证明</h4><p>　　用剩下的石子数$(a,b)$来表示状态.<br>　　根据定理”<strong>有限个节点的无回路有向图有唯一的核(终点)</strong>“, 我们可以用 <strong>backward induction</strong> 逐步递推出每种状态的胜负情况. 我们会发现, 对于先手的必败态是这么一些状态 $(0,0), (1,2), (3,5), (6,10)\cdots $, 或许可以从这些数字当中寻找到关于答案的信息.<br>　　记第 n 组必败态为 $(a_n,b_n)$.</p>
<ul>
<li>命题一: $a_n+1$是前$n$组必败态中从未出现过的最小正整数.<br>如果$a_{n+1}$不是未出现的数中最小的, 那么可以从$a_{n+1}$到达一个使$a_{n+1}$更小的状态.矛盾.</li>
<li>命题二: $b_n=a_n+n$<br>证明: 若前 $k$ 个必败态分别是 $(a_{k},a_{k}+k)$, 下一个必败态是 $(a_{k+1},a_{k+1}+k+1)$.<br>　　从第$k+1$个必胜态出发, 一共能走向三种状态,分别是 拿左边, 拿右边和都拿, 上面的 奇异局势性质 已经说明拿完之后的状态必定不是奇异局势, 下一个操作的人可以将其重新变成奇异局势.</li>
</ul>
<p>　　这样我们就得到了这个数列的递推式.<br>　　接下来我们将这两个命题看作是这个数列的定义, 来得到它的性质.</p>
<ul>
<li>性质一: $(a_n,b_n)$遍历所有正整数.</li>
<li>性质二: $A=a_{i},i=1,2,\cdots, B=a_{i},i=1,2,\cdots $, 则$A\cup B=\varnothing$.<br>可以知道$A$和$B$满足 Beatty定理.<br>$$a_n=\lfloor \alpha n\rfloor, b_n=\lfloor \beta n\rfloor, a_n+n=\lfloor(\alpha+1)n\rfloor=\lfloor \beta n \rfloor$$,<br>得<br>$$\frac{1}{\alpha+1}+\frac{1}{\alpha}=1$$<br>解得$$\alpha=\frac{\sqrt{5}+1}{2}$$<br>可以得到该数列的通项公式.<br>$$a_{i}=\alpha i,b_{i}=i\alpha^2=i\alpha+i$$</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/25/weizuofuth/" data-id="cjftq8nym008re0kepaw6i0e6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Beatty定理/">Beatty定理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ICG/">ICG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/威佐夫博弈/">威佐夫博弈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-onthetop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/onthetop/" class="article-date">
  <time datetime="2018-02-25T13:12:01.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/解决方案/">解决方案</a>►<a class="article-category-link" href="/categories/解决方案/Hexo/">Hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/onthetop/">Hexo 文章置顶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文参考了<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a>.</p>
<p>在<code>/node_modules/hexo-generator-index/lib/generator.js</code>中添加一段代码.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</div><div class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>最终<code>generator.js</code>的内容.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</div><div class="line">  <span class="keyword">var</span> posts = locals.posts;</div><div class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</div><div class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</div><div class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</div><div class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</div><div class="line">    <span class="attr">layout</span>: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</div><div class="line">    <span class="attr">format</span>: paginationDir + <span class="string">'/%d/'</span>,</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">      <span class="attr">__index</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/25/onthetop/" data-id="cjftq8nwn004be0kerv27ssfa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/解决方案/">解决方案</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-easygame" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/24/easygame/" class="article-date">
  <time datetime="2018-02-24T10:10:52.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/easygame/">简单博弈论题目选做</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h2><ul>
<li>感觉学习, 需要知其然知其所以然, 只背结论大概不行.</li>
<li>还得多啃书, 啃论文, 啃英文讲义, 对学习很有帮助.</li>
<li>推荐一个<a href="www.math.ucla.edu/~tom/Games/">网站</a>,上面又很多ICG游戏.</li>
<li>关于一些部分的内容可以在<a href="http://blog.csdn.net/clove_unique/article/details/53868567" target="_blank" rel="external">zyf</a>的blog里面找到.</li>
<li>题目有一部分主要是从某同学 <a href="cnblogs.com/zwfymqz">attack</a> 那里找的.</li>
<li>Matrix67 的 <a href="http://www.matrix67.com/blog/archives/6784" target="_blank" rel="external">blog</a>总能给我们一些惊喜.</li>
<li>博弈论比较全面的<a href="https://www.cnblogs.com/wujiechao/p/5365039.html" target="_blank" rel="external">总结</a>.</li>
</ul>
<h2 id="51nod-1066-Bash"><a href="#51nod-1066-Bash" class="headerlink" title="51nod 1066 Bash"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1066" target="_blank" rel="external">51nod 1066 Bash</a></h2><h3 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h3><p>　　有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。<br>　　例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>　　第2 - T + 1行：每行2个数N，K。中间用空格分隔。（1 &lt;= N,K &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p>4<br>3 2<br>4 2<br>7 3<br>8 3</p>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p>B<br>A<br>A<br>B</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>Bash游戏 0  Bash游戏 V2 10  Bash游戏 V3 20  Nim游戏 0  Bash游戏 V4 40 威佐夫游戏 0  威佐夫游戏 V2 0 </p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法:"></a>做法:</h3><p>　　分析一下在什么情况下A是必胜的, 或者直接使用 <strong>backward induction</strong> 强行推, 然后找规律, 后者就比较简单, 关键是对于前者的的考虑.<br>　　如果递推 SG函数 的话就会发现当 k 固定时, 先手必胜的条件是:<br>$$n\not \equiv 0 \mod k+1$$<br>　　那为什么这个结论是正确的我们发现, 无论后手拿出几个石子, 先手总能使这一轮两人拿出的石子之和等于 $k+1$ (反过来, 后手也能这么做无论先手想不想这么做), 从而决定着先手能不能找到一个必胜策略.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> T;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">	<span class="keyword">int</span> n,k;</div><div class="line">	<span class="keyword">while</span>(T--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</div><div class="line">		<span class="keyword">if</span>(n%(k+<span class="number">1</span>))<span class="built_in">printf</span>(<span class="string">"A\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="51nod-1067-Bash游戏-V2"><a href="#51nod-1067-Bash游戏-V2" class="headerlink" title="51nod 1067 Bash游戏 V2"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1067" target="_blank" rel="external">51nod 1067 Bash游戏 V2</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。<br>　　例如N=2A只能拿1颗，所以B可以拿到最后1颗石子。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>　　第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>　　第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>　　共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例-1"><a href="#Input示例-1" class="headerlink" title="Input示例"></a>Input示例</h3><p>3<br>2<br>3<br>4</p>
<h3 id="Output示例-1"><a href="#Output示例-1" class="headerlink" title="Output示例"></a>Output示例</h3><p>B<br>A<br>A</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法:"></a>做法:</h3><p>　　这个题目貌似很常见, 在我看过的一些英文讲义上貌似都有.下面那个表格就是……<br>　　这个题目我们同样可以考虑在程序中直接递推, 但是看到($n\leq 10^9$)就得乖乖放弃, 同样需要分析一下.<br>　　因为数据这么大肯定是$O(1)$做法因此可以找规律.<br>　　经过漫长的找规律, 我们发现好像没什么规律?<br><img src="http://aiyoupass.com/myjson/png2.png" alt="Png1"><br>　　真的没有规律吗?然而发现它是以一个 $PNPNNNN$为最小循环节的序列.N=A win!,P=B win!.</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> T;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(T--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">		<span class="keyword">if</span>(n%<span class="number">7</span>==<span class="number">0</span>||n%<span class="number">7</span>==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"B\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="51nod-1068-Bash游戏-V3"><a href="#51nod-1068-Bash游戏-V3" class="headerlink" title="51nod 1068 Bash游戏 V3"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1068" target="_blank" rel="external">51nod 1068 Bash游戏 V3</a></h2><p>题目来源： Ural 1180</p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16….)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。<br>　　例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数）</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>　　第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)<br>　　第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^1000)</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>　　共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例-2"><a href="#Input示例-2" class="headerlink" title="Input示例"></a>Input示例</h3><p>3<br>2<br>3<br>4</p>
<h3 id="Output示例-2"><a href="#Output示例-2" class="headerlink" title="Output示例"></a>Output示例</h3><p>A<br>B<br>A</p>
<h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法:"></a>做法:</h3><p>　　仍然可以采用找规律的方法, 当然会发现 SG 函数仍然是以$PPN$为最小循环节的序列.但是有没有什么可以证明这个结论是正确的呢?感觉大概是可以证明的, 但是还没找到一个证明?</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">while</span>(n--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;str;<span class="keyword">int</span> len=str.size();</div><div class="line">        <span class="keyword">int</span> he=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</div><div class="line">            he+=str[i]-<span class="string">'0'</span>;</div><div class="line">        <span class="keyword">if</span>(he%<span class="number">3</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"A\n"</span>;</div><div class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"B\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="51nod-1070-Bash游戏-V4"><a href="#51nod-1070-Bash游戏-V4" class="headerlink" title="51nod 1070 Bash游戏 V4"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1070" target="_blank" rel="external">51nod 1070 Bash游戏 V4</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。<br>　　例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。</p>
<h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例-3"><a href="#Input示例-3" class="headerlink" title="Input示例"></a>Input示例</h3><p>3<br>2<br>3<br>4</p>
<h3 id="Output示例-3"><a href="#Output示例-3" class="headerlink" title="Output示例"></a>Output示例</h3><p>B<br>B<br>A</p>
<h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><h4 id="斐波那契博弈问题"><a href="#斐波那契博弈问题" class="headerlink" title="斐波那契博弈问题"></a>斐波那契博弈问题</h4><p>　　可以看出这是一个简单的斐波那契博弈问题, 也就是当 n 为斐波那契数的时候后手必胜, 但是由于以前从未接触过斐波那契堆所以来学习一下.</p>
<h4 id="齐肯多夫定理"><a href="#齐肯多夫定理" class="headerlink" title="齐肯多夫定理"></a>齐肯多夫定理</h4><p>　　任何正整数都可以被表示成不连续的斐波那契堆之和的形式, 斐波那契堆就是依据这个定理.<br>　　这个定理可以利用归纳法证明, 首先对于任意非斐波那契数 n , 存在$Fib_{i}&lt;n&lt;Fib_{i+1}$, 我们取满足性质的最大的 $i$, 设$n’=n-Fib{i}$, 又因为$Fib_{i-1}+Fib_{i}=Fib{i+1}$, 所以$n’&lt; Fib_{i-1}$.所以对于$n’$相似的划分能进行下去, 因此定理成立.</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>　　证明对于 n 为斐波那契数先手必败.</p>
<ul>
<li>首先对于斐波那契数 $1,2,3$ 先手必败显然成立.</li>
<li>假设这个结论在$n\leq k$时成立,<br>对于$k+1$, $Fib_{k+1}=Fib_{k}+Fib_{k-1}$.<br>那么我们可以将这一堆石子看成两堆, 数量分别为$Fib_{k}$和$Fib_{k-1}$.<br>对于$Fib_{k-1}$先手总能取到最后一颗, 那么后手可以选择只取完$Fib_{k-1}$那么先手将面临取$Fib_{k}$的情况, 但是不同的是先手有可能会全部取完所以还需要考虑上一步后手取的数量.<br>通过归纳我们又知道后手在$Fib_{k-1}$取的最后一次不会超过$\frac{2}{3}Fib_{k-1}$, 所以先手在$Fib_{k}$堆中取的第一次不会超过$\frac{4}{3}Fib_{k-1}$.所以后手在$Fib_{k}$中仍然拥有必胜策略.</li>
</ul>
<p>问题得证</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</div><div class="line"><span class="keyword">int</span> Fib[N]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">int</span> n,now;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">50</span>;++i)</div><div class="line">		Fib[i]=Fib[i<span class="number">-1</span>]+Fib[i<span class="number">-2</span>];</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;now;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;++i)</div><div class="line">			<span class="keyword">if</span>(now==Fib[i])&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"B\n"</span>);</div><div class="line">				flag=<span class="literal">true</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">if</span>(!flag)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"A\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="51nod-1072-威佐夫游戏"><a href="#51nod-1072-威佐夫游戏" class="headerlink" title="51nod 1072 威佐夫游戏"></a><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1072" target="_blank" rel="external">51nod 1072 威佐夫游戏</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。<br>例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>
<h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>　　第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>　　第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000)</p>
<h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>　　共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例-4"><a href="#Input示例-4" class="headerlink" title="Input示例"></a>Input示例</h3><p>3<br>3 5<br>3 4<br>1 9</p>
<h3 id="Output示例-4"><a href="#Output示例-4" class="headerlink" title="Output示例"></a>Output示例</h3><p>B<br>A<br>A</p>
<h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>　　题目都说来这是一个威佐夫游戏, 那自然就是一个威佐夫游戏.正好我也没接触过威佐夫游戏题, 正好来接触一下.<br>关于此题的证明<a href="http://blog.sina.com.cn/s/blog_a661ecd501017out.html" target="_blank" rel="external">1</a>或者<a href="https://baike.baidu.com/item/%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88/19858256?fr=aladdin" target="_blank" rel="external">2</a>.<br>不过最精彩的还是 <strong>Matrix67</strong> 作出的(证明)[<a href="http://www.matrix67.com/blog/archives/6784" target="_blank" rel="external">http://www.matrix67.com/blog/archives/6784</a>]</p>
<h4 id="奇异局势"><a href="#奇异局势" class="headerlink" title="奇异局势"></a>奇异局势</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　如果此时局势是奇异局势, 那么此时操作的人将必败.$(0,0)$是奇异局势, 下面几个奇异局势分别为$(1,2), (3,5), (4,7), (6,10), (8,13), (9,15)$.<br>　　用$(a_i,b_i)$表示奇异局势, 那么它可以这么表示:</p>
<ul>
<li>$a_0=0$,$b_0=0$</li>
<li>$a_i$是从未在之前的$a_k,b_k (0\leq k\leq i-1) $中出现过的最小自然数, $b_i=a_i+i$</li>
</ul>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>1.任何自然数都包含在一个且仅有一个奇异局势中.<br>由于$a_k$是从未在前面出现过的最小自然数, 所以$a_k&gt;a_{k-1}$, 而$b_k=a_k+k&gt;a_{k-1}$.<br>2.任意操作都可将奇异局势变为非奇异局势.</p>
<ul>
<li>如果只改变$(a_i,b_i)$中的一个, 根据上述结论, 奇异局势一定被改变;</li>
<li>如果同时改变$(a_i,b_i)$为$(a_i-k,b_i-k)$, 因为$a_j+j=b_j$, 所以两者的差被改变,奇异局势被改变.</li>
<li>采取一定办法可以将非奇异局势转变为奇异局势.假设当前局势为$(a,b)$.<br>1.若$b=a$, 则同时从堆中取走 $a$ 个物品, 就变成来奇异局势;<br>2.若$\exists a_k=a$且$b&gt;b_k$, 则从$b$中取出$b_k-b$个即可;<br>3.若$\exists a_k=a$且$b&lt; b_k$, 则同时从两堆中拿走$a-a_{b-a}$个即可变成$(a_{b-a},a_{b-a}+b-a)$;<br>4.若$\exists b_k=b$且$a&gt;a_k$, 则从 $a$ 中拿出 $a-a_k$即可;<br>5.若$\exists b_k=b$且$a&lt; a_k$, 若$a=a_j or b_j$则从$b$中拿出$b-b_j$或$b-a_j$即可.<h4 id="Beatty-定理"><a href="#Beatty-定理" class="headerlink" title="Beatty 定理"></a>Beatty 定理</h4>　　这部分内容来自 Matrix67 的博客.<br>　　如果正无理数 $\alpha$ 和$ \beta$ 满足 $\frac{1}{\alpha}+\frac{1}{\beta}=1$, 则数列$\lfloor \alpha,2\dot \alpha,\cdots\rfloor$ 和 $\lfloor \beta,2\dot \alpha,\cdots $既无遗漏又不重复的包含了所有的正整数.</li>
</ul>
<p>**<br>　　首先注意到，如果 x 和 y 都不是整数，那么 [x] 严格地小于 x ，[y] 严格地小于 y ，从而 [x] + [y] &lt; x + y 。另外，[x] 一定严格地大于 x – 1 ， [y] 一定严格地大于 y – 1 ，从而 [x] + [y] 一定严格地大于 x + y – 2。这说明，当 x 和 y 都不是整数时， [x] + [y] 将介于 x + y – 2 和 x + y 之间。</p>
<p>　　回到原问题。显然，在数列 [1 · α], [2 · α], [3 · α], … 中，小于 n 的正整数有 [n / α] 个。显然，在数列 [1 · β], [2 · β], [3 · β], … 中，小于 n 的正整数有 [n / β] 个。因此，在这两个数列中，小于 n 的正整数共有 [n / α] + [n / β] 个。由于 α 和 β 都是无理数，因此 n / α 和 n / β 不可能为整数，由刚才的结论， [n / α] + [n / β] 一定介于 n / α + n / β – 2 和 n / α + n / β 之间，即 n – 2 和 n 之间。但是， [n / α] + [n / β] 是个整数，因而它精确地等于 n – 1 。</p>
<p>　　这说明，前 n – 1 个正整数在两个数列中一共出现了 n – 1 次，这对于所有 n 都成立。于是，正整数 1 必须且只能出现在其中一个数列中，正整数 2 必须且只能出现在其中一个数列中，以此类推，每一个新的正整数都必须且只能出现在其中一个数列中。</p>
<p>　　序列 W 的性质 2 则是， W 当中各项里的两数之差依次为 1, 2, 3, … ，也就是说第 n 个数对里的两数之差恰好为 n 。这一点也是很容易看出来的。由于 φ 满足 1 + φ = φ2 ，因而 n + n · φ = n · φ2 ，即 n · φ 和 n · φ2 正好相差 n 。如果两个数正好相差 n ，那么这两个数的整数部分显然也就正好相差 n 。这就证明了序列 W 满足性质 2 。</p>
<p>　　序列 W 的性质 3 则是， W 当中各项里的较小数依次递增，即 [1·φ], [2·φ], [3·φ], … 依次递增。这就更显然了：在数列 1·φ, 2·φ, 3·φ, … 中，后一项总比前一项大 φ ≈ 1.618 &gt; 1 ，因此即使取整后，后一项也一定严格地大于前一项。注意到，性质 2 和性质 3 结合起来可以告诉我们， W 当中各项里的较大数也是依次递增的。<br>**</p>
<h4 id="详细证明"><a href="#详细证明" class="headerlink" title="详细证明"></a>详细证明</h4><p>　　用剩下的石子数$(a,b)$来表示状态.<br>　　根据定理”<strong>有限个节点的无回路有向图有唯一的核(终点)</strong>“, 我们可以用 <strong>backward induction</strong> 逐步递推出每种状态的胜负情况. 我们会发现, 对于先手的必败态是这么一些状态 $(0,0), (1,2), (3,5), (6,10)\cdots $, 或许可以从这些数字当中寻找到关于答案的信息.<br>　　记第 n 组必败态为 $(a_n,b_n)$.</p>
<ul>
<li>命题一: $a_n+1$是前$n$组必败态中从未出现过的最小正整数.<br>如果$a_{n+1}$不是未出现的数中最小的, 那么可以从$a_{n+1}$到达一个使$a_{n+1}$更小的状态.矛盾.</li>
<li>命题二: $b_n=a_n+n$<br>证明: 若前 $k$ 个必败态分别是 $(a_{k},a_{k}+k)$, 下一个必败态是 $(a_{k+1},a_{k+1}+k+1)$.<br>　　从第$k+1$个必胜态出发, 一共能走向三种状态,分别是 拿左边, 拿右边和都拿, 上面的 奇异局势性质 已经说明拿完之后的状态必定不是奇异局势, 下一个操作的人可以将其重新变成奇异局势.</li>
</ul>
<p>　　这样我们就得到了这个数列的递推式.<br>　　接下来我们将这两个命题看作是这个数列的定义, 来得到它的性质.</p>
<ul>
<li>性质一: $(a_n,b_n)$遍历所有正整数.</li>
<li>性质二: $A=a_{i},i=1,2,\cdots, B=a_{i},i=1,2,\cdots $, 则$A\cup B=\varnothing$.<br>可以知道$A$和$B$满足 Beatty定理.<br>$$a_n=\lfloor \alpha n\rfloor, b_n=\lfloor \beta n\rfloor, a_n+n=\lfloor(\alpha+1)n\rfloor=\lfloor \beta n \rfloor$$,<br>得<br>$$\frac{1}{\alpha+1}+\frac{1}{\alpha}=1$$<br>解得$$\alpha=\frac{\sqrt{5}+1}{2}$$<br>可以得到该数列的通项公式.<br>$$a_{i}=\alpha i,b_{i}=i\alpha^2=i\alpha+i$$</li>
</ul>
<h2 id="Poj-2484-A-Funny-Game"><a href="#Poj-2484-A-Funny-Game" class="headerlink" title="Poj 2484 A Funny Game"></a><a href="http://poj.org/problem?id=2484" target="_blank" rel="external">Poj 2484 A Funny Game</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　Alice and Bob decide to play a funny game. At the beginning of the game they pick n(1 &lt;= n &lt;= 106) coins in a circle, as Figure 1 shows. A move consists in removing one or two adjacent coins, leaving all other coins untouched. At least one coin must be removed. Players alternate moves with Alice starting. The player that removes the last coin wins. (The last player to move wins. If you can’t move, you lose.)<br><img src="http://poj.org/images/2484_1.jpg" alt="Png1"><br>　　<strong>Note</strong>: For n &gt; 3, we use c1, c2, …, cn to denote the coins clockwise and if Alice remove c2, then c1 and c3 are NOT adjacent! (Because there is an empty place between c1 and c3.)<br>　　Suppose that both Alice and Bob do their best in the game.<br>You are to write a program to determine who will finally win the game.</p>
<p>###Input<br>　　There are several test cases. Each test case has only one line, which contains a positive integer n (1 &lt;= n &lt;= 106). There are no blank lines between cases. A line with a single 0 terminates the input. </p>
<p>###Output<br>　　For each test case, if Alice win the game,output “Alice”, otherwise output “Bob”. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>1<br>2<br>3<br>0</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>Alice<br>Alice<br>Bob</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>POJ Contest,Author:Mathematica@ZSU</p>
<h3 id="做法-5"><a href="#做法-5" class="headerlink" title="做法:"></a>做法:</h3><p>　　这个题目比较奇怪, 当然奇怪的题目太多了.<br>　　看上去题意不是很好做, SG函数貌似没法求.但是我们依然可以用最简单的方式做这道题目————猜, 如果猜对了我们会发现这个题确实不难.<br>　　可以知道 n=1,2 的情况先手必胜, n=3 的情况先手必败.<br>　　如果玩过围棋的话就知道模拟棋这一玩法, 在这个游戏中有着玩模拟棋的特征, 在 n 为偶数的情况下硬币是相互对称的, 因此我们可以推测如果后手一直采用模拟棋的套路, 他一定是必胜的.<br>　　那如果是 n 为奇数的情况呢, 我们仍然可以采用模拟棋的思路来考虑, 将局面转变为偶数的情况, 可以知道如果先手拿一个硬币后手就拿两个, 拿两个后手拿一个.<br>    所以在 $n\geq 3$ 的情况下先手没法赢.</p>
<p>　　至于编程, …… 只需要判断 $n$ 是否大于 2 就好了.</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">if</span>(!n)<span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(n&gt;<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"Bob\n"</span>);</div><div class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Alice\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="BZOJ-1299-LLH邀请赛-巧克力棒"><a href="#BZOJ-1299-LLH邀请赛-巧克力棒" class="headerlink" title="BZOJ 1299: [LLH邀请赛]巧克力棒"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1299" target="_blank" rel="external">BZOJ 1299: [LLH邀请赛]巧克力棒</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>TBL和X用巧克力棒玩游戏。每次一人可以从盒子里取出若干条巧克力棒，或是将一根取出的巧克力棒吃掉正整数长度。TBL先手两人轮流，无法操作的人输。 他们以最佳策略一共进行了10轮（每次一盒）。你能预测胜负吗？</p>
<h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>输入数据共20行。 第2i-1行一个正整数Ni，表示第i轮巧克力棒的数目。 第2i行Ni个正整数Li,j，表示第i轮巧克力棒的长度。</p>
<h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>输出数据共10行。 每行输出“YES”或“NO”，表示TBL是否会赢。如果胜则输出”NO”,否则输出”YES”</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>3<br>11 10 15<br>5<br>13 6 7 15 3<br>2<br>15 12<br>3<br>9 7 4<br>2<br>15 12<br>4<br>15 12 11 15<br>3<br>2 14 15<br>3<br>3 16 6<br>4<br>1 4 10 3<br>5<br>8 7 7 5 12 </p>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>YES<br>NO<br>YES<br>YES<br>YES<br>NO<br>YES<br>YES<br>YES<br>NO</p>
<h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>20%的分数，N&lt;=5，L&lt;=100。<br>40%的分数，N&lt;=7。 50%的分数，L&lt;=5,000。<br>100%的分数，N&lt;=14，L&lt;=1,000,000,000。</p>
<h3 id="做法-6"><a href="#做法-6" class="headerlink" title="做法"></a>做法</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>　　这个题目给出十盒巧克力棒, 一盒巧克力棒是一局游戏, 在一场游戏中, 人每次可以拿出若干根巧克力或者吃掉一根巧克力棒的一部分.一根巧克力棒可以看作是一堆石子, 一盒巧克力是很多堆石子, 实际上这就是一个改变的取石子游戏.<br>　　考虑为先手寻找一个必胜策略, 我们可以类比 <strong>nim游戏</strong> .如果在先手的回合后石子堆的异或和为0, 在 nim 游戏中先手必胜.在这个题目中, 先手必须得先拿出若干堆石子然后才可以继续后面的游戏, 所以如何拿取石子非常重要.</p>
<h4 id="必胜策略"><a href="#必胜策略" class="headerlink" title="必胜策略"></a>必胜策略</h4><p>　　首先假设后手不会在当前石子全部拿完之前又拿出新的石子,当然对结果没有影响, 这样方便后面的讨论.如果先手首先拿取了$m$堆石子的话, 将会剩下$n-m$堆石子, 我们很容易想到如果取出的$m$堆石子异或和为0的话, 先手将必定会拿走这些石子的最后一些石子, 后手被迫从剩下很多堆选择一些拿出来, 这样又形成了新的子问题.如果后手拿出的石子满足先手仍然可以拿走最后一些石子的话, ……可以判定先手具有必胜策略.<br>　　根据我们处理 nim 游戏的经验, 如果满足上述条件的话, 必定存在堆的石子数量异或和不为零.这样我们可以推断$n-m$堆石子的数量的异或和不为0,也就是先手拿出的$n$堆石子是元素数量最大的异或和为零的所有石子堆的子集.这样先手获胜的策略就是首先拿出异或和为零最大的石子堆然后保证每次取石子都使自己拿走最后一些石子.</p>
<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>　　那如何判断到底是谁获胜呢, 我们在编程中不需要找出这个异或和为零的最大子集, 只需要确定存在一个异或和为零的集合即可, 这个过程可以 dfs 实现($n\leq 14$).</p>
<h4 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示:"></a>友情提示:</h4><p>　　如果获胜输出”NO”……请注意读题.</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> s;</div><div class="line">	<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">	<span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">	<span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> n,ans;</div><div class="line"><span class="keyword">int</span> cirleplus;</div><div class="line"><span class="keyword">int</span> xuanze[<span class="number">255</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(x==n&amp;&amp;!cirleplus&amp;&amp;sum)ans=<span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(x&gt;=n)<span class="keyword">return</span> ;</div><div class="line">	dfs(x+<span class="number">1</span>,sum);</div><div class="line">	cirleplus^=xuanze[x];</div><div class="line">	dfs(x+<span class="number">1</span>,sum+<span class="number">1</span>);</div><div class="line">	cirleplus^=xuanze[x];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;n;cirleplus=ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</div><div class="line">			xuanze[j]=read();</div><div class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span>(!ans)<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="BZOJ-1874-BeiJing2009-WinterCamp-取石子游戏"><a href="#BZOJ-1874-BeiJing2009-WinterCamp-取石子游戏" class="headerlink" title="BZOJ 1874: [BeiJing2009 WinterCamp]取石子游戏"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1874" target="_blank" rel="external">BZOJ 1874: [BeiJing2009 WinterCamp]取石子游戏</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>　　小H和小Z正在玩一个取石子游戏。 取石子游戏的规则是这样的，每个人每次可以从一堆石子中取出若干个石子，<br>每次取石子的个数有限制，谁不能取石子时就会输掉游戏。 小H先进行操作，他想问你他是否有必胜策略，如果有<br>，第一步如何取石子。</p>
<h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>　　输入文件的第一行为石子的堆数N<br>接下来N行，每行一个数Ai，表示每堆石子的个数 接下来一行为每次取石子个数的种类数M 接下来M行，每行一个数Bi，表示每次可以取的石子个数，<br>　　输入保证这M个数按照递增顺序排列。<br>　　N≤10    Ai≤1000 对于全部数据，M≤10，Bi≤10 </p>
<h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>　　输出文件第一行为“YES”或者“NO”，表示小H是否有必胜策略。<br>若结果为“YES”,则第二行包含两个数，第一个数表示从哪堆石子取，第二个数表示取多少个石子，<br>　　若有多种答案，取第一个数最小的答案，<br>　　若仍有多种答案，取第二个数最小的答案。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>4<br>7<br>6<br>9<br>3<br>2<br>1<br>2</p>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>YES<br>1 1</p>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>样例中共有四堆石子，石子个数分别为7、6、9、3，每人每次可以从任何一堆石子中取出1个或者2个石子，小H有<br>必胜策略，事实上只要从第一堆石子中取一个石子即可。</p>
<h4 id="Source-1"><a href="#Source-1" class="headerlink" title="Source"></a>Source</h4><p>Day2</p>
<h3 id="做法-7"><a href="#做法-7" class="headerlink" title="做法"></a>做法</h3><p>　　这显然和普通的 nim 取石子游戏不一样, 只能取某些数量的石子, 而且要求求出方案数.</p>
<p>　　只需要根据递推 SG函数即可, 根据 SG定理, 游戏的和等于 SG函数的异或和.至于如何取, 暴力枚举即可.</p>
<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">namespace</span> Input&#123;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;s)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch=getchar();</div><div class="line">        <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">        <span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">    &#125;</div><div class="line">&#125;;<span class="keyword">using</span> <span class="keyword">namespace</span> Input;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> a[N],b[N];</div><div class="line"><span class="keyword">bool</span> S[N];</div><div class="line"><span class="keyword">int</span> sg[N];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    read(n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)read(a[i]);</div><div class="line">    read(m);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)read(b[i]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;++i)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1000</span>;++j)S[j]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;b[j]&lt;=i;++j)</div><div class="line">            S[sg[i-b[j]]]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;;++j)</div><div class="line">            <span class="keyword">if</span>(!S[j])&#123;</div><div class="line">                sg[i]=j;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</div><div class="line">        ans^=sg[a[i]];</div><div class="line">    <span class="keyword">if</span>(!ans)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;b[j]&lt;=a[i];++j)</div><div class="line">            <span class="keyword">if</span>(!(sg[a[i]]^sg[a[i]-b[j]]^ans))&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n%d %d"</span>,i,b[j]);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="BZOJ-1115-POI2009-石子游戏Kam"><a href="#BZOJ-1115-POI2009-石子游戏Kam" class="headerlink" title="BZOJ 1115: [POI2009]石子游戏Kam"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1115" target="_blank" rel="external">BZOJ 1115: [POI2009]石子游戏Kam</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>有N堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。</p>
<h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>第一行u表示数据组数。对于每组数据，第一行N表示石子堆数，第二行N个数ai表示第i堆石子的个数(a1&lt;=a2&lt;=……&lt;=an)。 1&lt;=u&lt;=10 1&lt;=n&lt;=1000 0&lt;=ai&lt;=10000</p>
<h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>u行，若先手必胜输出TAK，否则输出NIE。</p>
<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>2<br>2<br>2 2<br>3<br>1 2 4</p>
<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>NIE<br>TAK</p>
<h4 id="HINT-1"><a href="#HINT-1" class="headerlink" title="HINT"></a>HINT</h4><p>感谢MT大牛翻译.</p>
<h3 id="做法-8"><a href="#做法-8" class="headerlink" title="做法:"></a>做法:</h3><p>　　看起来摸不清头脑, 实际上只需要一个巧妙的转换, 终止情况是将石子变为每堆都相同的情况.<br>　　所以只需要对原序列进行<strong>差分</strong>, 然后就问题就变成了将差分后序列变为 2——n 位为零的情况, 这个问题和阶梯石子游戏等价.相当与是将一些阶梯上的石子移到第一阶.做法为将奇数阶上石子求异或和为整个游戏的 SG 函数.</p>
<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">    <span class="keyword">while</span>(T--)&#123;</div><div class="line">        <span class="keyword">int</span> N,ans=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;N;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=<span class="number">2</span>;i--)a[i]=a[i]-a[i<span class="number">-1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=<span class="number">1</span>;i--) </div><div class="line">            <span class="keyword">if</span>((N-i+<span class="number">1</span>)%<span class="number">2</span>)ans=ans^a[i];</div><div class="line">        <span class="built_in">printf</span>(ans?<span class="string">"TAK\n"</span>:<span class="string">"NIE\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1],<a href="https://baike.baidu.com/" target="_blank" rel="external">https://baike.baidu.com/</a>,关于”<br>威佐夫博弈”等条目;<br>[2],<a href="http://attack204.com/" target="_blank" rel="external">http://attack204.com</a>,关于”斐波那契博弈”与”威佐夫博弈”;<br>[3],<a href="http://blog.csdn.net/dgq8211/article/details/7602807" target="_blank" rel="external">http://blog.csdn.net/dgq8211/article/details/7602807</a>,关于斐波那契博弈;<br>[4],<a href="https://www.math.ucla.edu/~tom/Game_Theory/comb.pdf" target="_blank" rel="external">https://www.math.ucla.edu/~tom/Game_Theory/</a>, Thomas S. Ferguson.<br>[4],<a href="http://web.mit.edu/sp.268/www/nim.pdf" target="_blank" rel="external">http://web.mit.edu/sp.268/www/nim.pdf</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/24/easygame/" data-id="cjftq8nve002oe0kei0sr22mi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Beatty定理/">Beatty定理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ICG/">ICG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zeckendorf定理/">Zeckendorf定理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nim/">nim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/一堆简单题/">一堆简单题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/威佐夫博弈/">威佐夫博弈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/巴什博弈/">巴什博弈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/规律/">规律</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/题目/">题目</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-p2197" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/24/p2197/" class="article-date">
  <time datetime="2018-02-24T06:10:52.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/p2197/">P2197 nim游戏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>甲，乙两个人玩Nim取石子游戏。<br>nim游戏的规则是这样的：地上有n堆石子（每堆石子数量小于10000），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数T&lt;=10,表示有T组数据<br>接下来每两行是一组数据，第一行一个整数n，表示有n堆石子，n&lt;=10000;<br>第二行有n个数，表示每一堆石子的数量</p>
<h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>共T行，如果对于这组数据存在先手必胜策略则输出”Yes”,否则输出”No”，不包含引号，每个单词一行。</p>
<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><p>2<br>2<br>1 1<br>2<br>1 0</p>
<h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><p>No<br>Yes</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>　　正确做法是将所有石子求异或和, 如果异或和为零则后手必胜; 否则后手必胜.<br>为什么这个结论是正确的呢?<br>　　首先如果石子中的异或和不为0, 先手一定可以在一步之内将其变成0(通过取最高位上为1的那一堆石子).所以先手必胜.<br>　　如果异或和为0, 先手无论如何取异或和都不会为0, 所以先手必败.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))ch=getchar();</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> T,n,m,add;</div><div class="line">    T=read();</div><div class="line">    <span class="keyword">while</span>(T--)&#123;</div><div class="line">        add=<span class="number">0</span>;n=read();</div><div class="line">        <span class="keyword">while</span>(n--)add^=read();</div><div class="line">        <span class="keyword">if</span>(!add)<span class="built_in">printf</span>(<span class="string">"No\n"</span>);</div><div class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/24/p2197/" data-id="cjftq8nxc005ne0ke7alq3cm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nim/">nim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-anotcommondinic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/23/anotcommondinic/" class="article-date">
  <time datetime="2018-02-23T13:10:59.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/">题目</a>►<a class="article-category-link" href="/categories/信息学竞赛/题目/模板/">模板</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/23/anotcommondinic/">一份不普通的Dinic</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Loj-101-最大流"><a href="#Loj-101-最大流" class="headerlink" title="Loj #101 最大流"></a>Loj #101 <a href="https://loj.ac/problem/101" target="_blank" rel="external">最大流</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>这是一道模板题。<br>给定 n  个点， m 条边，给定每条边的容量，求从点  s 到点  t 的最大流。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行四个整数 n,m,s,t 。<br>接下来的 m  行，每行三个整数 u,v,c 表示 u 到 v，流量为 c 的一条边。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出点 s 到点  t 的最大流。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>7 14 1 7<br>1 2 5<br>1 3 6<br>1 4 5<br>2 3 2<br>2 5 3<br>3 2 2<br>3 4 3<br>3 5 3<br>3 6 7<br>4 6 5<br>5 6 1<br>6 5 1<br>5 7 8<br>6 7 7</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>14</p>
<h3 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h3><p> 1 \leqslant n \leqslant 10 ^ 6, 1 \leqslant m \leqslant 4 \times 10 ^ 6, 0 \leqslant c \leqslant 2 ^ {31} - 1 </p>
<h3 id="分类标签"><a href="#分类标签" class="headerlink" title="分类标签"></a>分类标签</h3><p>模板  最大流  网络流  子任务</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>　　只要是最大流的做法基本上都可以, 包括 <strong>EK算法</strong>, <strong>Dinic 算法</strong>, <strong>ISAP 算法</strong>, <strong>预留推进算法</strong>.<br>    但是速度相差可以达到十倍以上.<a href="https://loj.ac/problem/101/statistics/fastest?page=1" target="_blank" rel="external">Rank</a><br>　　一般情况下人们写 Dinic 的比较普遍, 因为既好写性能还很好; 也有人喜欢写 ISAP 虽然代码比较长但是性能非常不错.<br>　　下面是 Rank 上第三的代码, 仔细观察可以发现一些有趣的事情.<br><em>代码来自(<a href="https://loj.ac/submission/6331)[https://loj.ac/submission/6331" target="_blank" rel="external">https://loj.ac/submission/6331)[https://loj.ac/submission/6331</a>]</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() ((TT==mo&amp;&amp;(mo=(TT=but)+fread(but,1,L,stdin)),TT==mo)?0:*TT++)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MX=<span class="number">1000011</span>,inf=~<span class="number">0u</span>&gt;&gt;<span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">char</span> *TT,*mo,but[L];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, c = <span class="number">0</span>, f = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getc())f=c!=<span class="string">'-'</span>;</div><div class="line">    <span class="keyword">for</span> (;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getc())x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</div><div class="line">    <span class="keyword">return</span> f ? x : -x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">struct</span> E&#123;</div><div class="line">	<span class="keyword">int</span> t,f;E* r;</div><div class="line">	E(<span class="keyword">int</span> <span class="keyword">_t</span>=<span class="number">0</span>,<span class="keyword">int</span> _f=<span class="number">0</span>,E* _r=<span class="literal">NULL</span>):t(<span class="keyword">_t</span>),f(_f),r(_r)&#123;&#125;</div><div class="line">&#125;pool[MX&lt;&lt;<span class="number">3</span>],*G[MX],*cur[MX];</div><div class="line"><span class="keyword">struct</span> Edge&#123;</div><div class="line">	<span class="keyword">int</span> u,v,f;</div><div class="line">	Edge(<span class="keyword">int</span> _u=<span class="number">0</span>,<span class="keyword">int</span> _v=<span class="number">0</span>,<span class="keyword">int</span> _f=<span class="number">0</span>):u(_u),v(_v),f(_f)&#123;&#125;</div><div class="line">&#125;e[MX&lt;&lt;<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,m,S,T,D[MX];</div><div class="line"><span class="keyword">int</span> vis[MX],lv[MX],tim;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Q[MX];</div><div class="line">	<span class="keyword">int</span> head,tail;</div><div class="line">	head=tail=<span class="number">0</span>;</div><div class="line">	Q[tail++]=S,vis[S]=<span class="number">1</span>,lv[S]=++tim;</div><div class="line">	<span class="keyword">while</span> (head&lt;tail)&#123;</div><div class="line">		<span class="keyword">int</span> x=Q[head++];</div><div class="line">		<span class="keyword">if</span>(x==T)<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		<span class="keyword">for</span>(E *i=G[x];i!=G[x+<span class="number">1</span>];i++)&#123;</div><div class="line">			<span class="keyword">if</span>(i-&gt;f&amp;&amp;lv[i-&gt;t]!=tim)&#123;</div><div class="line">				lv[i-&gt;t]=tim,vis[i-&gt;t]=vis[x]+<span class="number">1</span>;</div><div class="line">				Q[tail++]=i-&gt;t;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> maxf)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(x==T||!maxf)<span class="keyword">return</span> maxf;</div><div class="line">	<span class="keyword">int</span> left=maxf;</div><div class="line">	<span class="keyword">for</span>(E *i=G[x];i!=G[x+<span class="number">1</span>];i++)&#123;</div><div class="line">		<span class="keyword">if</span>(i-&gt;f&amp;&amp;lv[i-&gt;t]==tim&amp;&amp;vis[i-&gt;t]==vis[x]+<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">int</span> f=dfs(i-&gt;t,min(left,i-&gt;f));</div><div class="line">			<span class="keyword">if</span>(!f)vis[i-&gt;t]=<span class="number">-1</span>;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				left-=f,i-&gt;f-=f,i-&gt;r-&gt;f+=f;</div><div class="line">				<span class="keyword">if</span>(!left)<span class="keyword">return</span> maxf;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> maxf-left;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (bfs())</div><div class="line">		ret+=dfs(S,inf);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n=rd(),m=rd(),S=rd(),T=rd();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">		<span class="keyword">int</span> u=rd(),v=rd(),f=rd();</div><div class="line">		e[i]=Edge(u,v,f);</div><div class="line">		++D[u],++D[v];</div><div class="line">	&#125;</div><div class="line">	G[<span class="number">1</span>]=pool;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)G[i+<span class="number">1</span>]=G[i]+D[i];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">		--D[e[i].u],--D[e[i].v];</div><div class="line">		G[e[i].u][D[e[i].u]]=E(e[i].v,e[i].f,G[e[i].v]+D[e[i].v]);</div><div class="line">		G[e[i].v][D[e[i].v]]=E(e[i].u,<span class="number">0</span>,G[e[i].u]+D[e[i].u]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如, 可以发现它使用结构体指针, 在阅读代码的时候如果不仔细阅读会不知道其什么含义.而且使用指针性能方面会好一些.还是要多阅读别人的代码特别是高手们的代码, 会学习到不少东西.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/23/anotcommondinic/" data-id="cjftq8nu6000re0kecoeb1xfy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/指针/">指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最大流/">最大流</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模板/">模板</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络流/">网络流</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sgTheorem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/sgTheorem/" class="article-date">
  <time datetime="2018-02-22T07:38:32.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/sgTheorem/">SG函数和SG定理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Kinds-of-Games-We’ll-Discuss"><a href="#Kinds-of-Games-We’ll-Discuss" class="headerlink" title="Kinds of Games We’ll Discuss"></a>Kinds of Games We’ll Discuss</h3><p>　　Much of the game theory we will talk about will be on combinatorial<br>games which have the following properties:</p>
<ul>
<li>There are two players.</li>
<li>There is a finite set of positions available in the game (only on rare<br>occasions will we mention games with infinite sets of positions).</li>
<li>Rules specify which game positions each player can move to.</li>
<li>Players alternate moving.</li>
<li>The game ends when a player can’t make a move.</li>
<li>The game eventually ends (it’s not infinite).<br>Today we’ll mostly talk about impartial games. In this type of game, the<br>set of allowable moves depends only on the position of the game and not on<br>which of the two players is moving. For example, Nim, sprouts, and green<br>hackenbush are impartial, while games like GO and chess are not (they are<br>called partisan).<br>　　这是来自MIT的一篇论文上对于 Impartial Games 的表述, 它属于组合游戏的一种, 事实上, SG定理所涉及的就是这一类游戏.</li>
</ul>
<h3 id="The-Game-of-Nim"><a href="#The-Game-of-Nim" class="headerlink" title="The Game of Nim"></a>The Game of Nim</h3><h4 id="How-to-play"><a href="#How-to-play" class="headerlink" title="How to play"></a>How to play</h4><p>　　有三堆石子, 两个人依次从任意一堆中拿出任意多个直到所有石子被拿光.这个游戏有两种版本和两种不同的获胜策略.(<em>可以在这里玩<a href="http://www.dotsphinx.com/nim/" target="_blank" rel="external">http://www.dotsphinx.com/nim/</a></em>)</p>
<ul>
<li><strong>一般玩法</strong> 拿走最后一个石子的人获胜.</li>
<li><strong>Misere 玩法</strong>拿走最后一个石子的人失败.(<em>Misese 在 wiki 上给了解释, 大概是规则完全相反的意思</em>)</li>
</ul>
<p>　　在最早的玩法中, 三堆石子数分别是 3,4,5.人们很快发现了必胜策略, 像先取 第一堆石子 中的 2 颗石子, 接着无论对手怎样出, 都能获胜.下面是一组例子.<br><img src="\myjson\png1.png" alt="png1"></p>
<h4 id="必胜态和必败态"><a href="#必胜态和必败态" class="headerlink" title="必胜态和必败态"></a>必胜态和必败态</h4><h5 id="P-position"><a href="#P-position" class="headerlink" title="P-position"></a><strong>P-position</strong></h5><p>　　P代表 Previous. 含义是上一次操作的人有必胜策略的局面是 <strong>P-position</strong>.也就是 “后手必胜”或者”先手必败”.它还包括无法进行任何移动的场面<strong>treminal position</strong></p>
<h5 id="N-position"><a href="#N-position" class="headerlink" title="N-position"></a><strong>N-position</strong></h5><p>　　N代表 Next.含义是先手保证必胜的状态.</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h5><ul>
<li>无法进行任何移动的局面是 P-position;</li>
<li>可以移动到 P-position 的局面是 N-position;</li>
<li>所有移动都导致 N-position 的局面是 P-position.<br>　　不如从直观的角度理解这一概念, </li>
<li>当一个局面无法进行任何操作的时候, 根据游戏的定义, 此时进行操作的人也就是先手必败.</li>
<li>当一个局面存在一个后继状态使得下一次操作的人必输, 此时操作的人可以选择这个后继状态从而获胜, 即先手必胜.</li>
<li>当一个局面它的后继状态都会使得下一个操作的人必胜时, 当前操作的人也就是先手必败.</li>
</ul>
<p>　　为了知道一个局面对先手来说是必败点还是必胜点, 我们在一个从结束往游戏的开始工作的过程称为<strong>backwards induction(大概是向后归纳)</strong>.<br>　　<br>　　对于 Misere 玩法, 结束状态是 N. </p>
<h5 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice 1"></a>Practice 1</h5><p>  有一堆石子, 两个人可以从集合$S={1,3,4}$中选择任意数字$s_i$, 并取走$s_i$个石子, 取到最后一个石子的人输.<br>  分析: 我们可以发现 1, 3 和 4 一定是 N-position, 2 一定是 P-position 因为唯一的移动是成为 N-position. 5 和 6 一定是 N-position 因为他们可以移动到 2.如果我们继续这个过程我们可以得到关于 N 和一个序列.<img src="\myjson\png2.png" alt="png2"><br>　　这个周期序列(PNPNNNN)将永远持续. 事实上, 几乎所有的减法游戏都存在类似的关于 N 和 P 的周期性序列.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/22/sgTheorem/" data-id="cjftq8ny6007ve0keyhunu898" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博弈论/">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-doublebackpacks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/21/doublebackpacks/" class="article-date">
  <time datetime="2018-02-21T03:47:51.000Z" itemprop="datePublished">2018-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/信息学竞赛/">信息学竞赛</a>►<a class="article-category-link" href="/categories/信息学竞赛/总结/">总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/21/doublebackpacks/">多重背包的快速解法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h3><p>　　关于背包问题自然是接触的不少, 包括 <strong>01背包</strong> , <strong>完全背包</strong> , <strong>多重背包</strong> 等等, <em>有关背包问题的详细解法可以参考<a href="">背包九讲</a></em>  这里主要介绍有关多重背包的解法.</p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>　　首先回顾０１背包的解法.01背包是指一类求在一定体积内装入有一定体积和价值的物品所产生的最大价值, 每个物品仅有一个.</p>
<h4 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h4><p>　　设$f_{i,j}$表示考虑装入前$i$个物品中若干个物品且背包体积为$j$时的最大价值.它由$f_{i-1,j-w_i}$来更新, 表示在装入$i-1$个物品后再装入体积为$w_i$物品$i$总体积为$j$的情况.</p>
<h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>　　如何转移这个状态呢.根据上面的论述, 状态转移方程应该这么表示:<br>$$f_{i,j}=\max{f_{i-1,j-w_i}+value_i,f_{i-1,j}}$$<br>　　在程序中, 我们需要先枚举每个物品, 然后枚举装下它的总体积来更新状态. </p>
<h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F[0,0..V ] ← 0</div><div class="line">	for i ← 1 to N</div><div class="line">		for v ← C i to V</div><div class="line">		F[i,v] ← max&#123;F[i - 1,v],F[i - 1,v - C i ] + W i &#125;</div></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>　　可以发现上述状态表示的第一维完全可以通过优化去掉的, 通过这样可以优化空间复杂度.<br>　　我们发现状态$f_{i,j}$完全是通过状态$f_{i-1,k}$来优化的, 那么只要我们保证每次用来更新的状态都是$f_{i-1,k}$即可, 可是在上述的伪代码中, 这样的要求是无法满足的, 我们发现如果只是去掉一维状态, 容易发现用来更新$f_{i,j}$的状态可能是$f_{i,k}$( <em>不用担心可能会使用$f_{i-l,k}$来更新状态, 它没有影响.</em> ), 如何处理这种情况呢, 有一个巧妙的办法, <strong>更改枚举体积的顺序</strong>, 我们发现这样先更新$f_{i,j}$, 然后才会更新$f_{i,k},k\leq j$, 这样较大的$j$就不会对较小的$k$产生影响了.<br>　　在应用中, 它的使用非常广泛, 它能大幅度减少其空间消耗, 这点可以从实际编写程序中几乎没有用二维状态表示的人看出.<strong>所以后面所有的问题, 都是基于一维状态表示处理的</strong>.</p>
<h5 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F[0..V ]←0</div><div class="line">	for i ← 1 to N</div><div class="line">		for v ← V to C i</div><div class="line">			F[v] ← max&#123;F[v],F[v - C i ] + W i &#125;</div></pre></td></tr></table></figure>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1:"></a>例题1:</h4><p>　　<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1085" target="_blank" rel="external">51nod 1085 背包问题</a><br>这就是一个01背包问题.</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> Input&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;s)</span></span>&#123;</div><div class="line">		<span class="keyword">char</span> ch=getchar();</div><div class="line">		<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">		<span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">	&#125;</div><div class="line">&#125;;<span class="keyword">using</span> <span class="keyword">namespace</span> Input;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,V;</div><div class="line"><span class="keyword">int</span> dp[N];</div><div class="line"><span class="keyword">int</span> num[N],v[N],w[N];</div><div class="line"><span class="keyword">int</span> tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	read(n),read(V);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</div><div class="line">		read(v[i]),read(w[i]);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=V;k&gt;=v[i];k--)</div><div class="line">			dp[k]=max(dp[k],dp[k-v[i]]+w[i]);</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;++i)</div><div class="line">		ans=max(ans,dp[i]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>　　完全背包是对01背包问题的延伸, 其改变是每个物品可以选择无限个.即使有了这个看似麻烦的限制, 我们依然可以通过对01背包的解法作出一定改进使其能处理完全背包问题.</p>
<h4 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h4><p>　　作出的一个最简单的修改是枚举放入物品$i$0件,1件,2件,$\cdots$,$\lfloor\frac{V}{w_{i}}\rfloor$件.实现非常简单,但这样的复杂度貌似略大,是$O(nV\sum\lfloor\frac{V}{w_{i}}\rfloor)$.很多情况下无法接受这样的复杂度.</p>
<h4 id="转化为01背包"><a href="#转化为01背包" class="headerlink" title="转化为01背包"></a>转化为01背包</h4><p>　　或许可以将完全背包中一种有$k$件的物品转化为$k$件完全无关的物品, 但这样似乎在效率上和上面的方法完全相同而且加大的空间消耗.<br>　　但是有一种更为巧妙的方式可以在将其转化为01背包且加快了效率.<strong>利用二进制拆分</strong>.在将这$k$件物品转化为一件一件物品时, 有没有一种方式能减少其分组的数量而且不能改变其物品总数?联想到任何一个数都可以用二进制表示, 同样这$k$件物品也可以用二进制的方式表示, 使得任意组合可以产生任何的物品总数$i,0\leq i\leq k$.根据这个思路, 我们大概可以构造出这么一组数$$1,2,\cdots,2^p,num-\sum_{i=0}^{p}2^i$$<br>　　容易发现这正是我们所要求的.<br>　　解法也就呼之欲出了, 将每种物品按照上述形式拆分, 按照01背包的形式做即可.但是因为后面还会涉及这种巧妙思路, 所以例题和程序在后面给出.</p>
<h4 id="巧妙的解法"><a href="#巧妙的解法" class="headerlink" title="巧妙的解法"></a>巧妙的解法</h4><p>　　或许还存在一种效率更好的解法? $O(nV)$的解法是否存在?<br>　　在01背包中曾提到过枚举背包体积顺序的问题, 现在这个思路将成为关键.<br>　　我们知道如果更改枚举体积的顺序, 将会导致状态转移的错误, 它会使$f_{i,j}$从$f_{i,k}$来转移, 其实际含义是在放入$i$件物品且体积为$k$的背包中再放入第$i$件物品, 而且这种转移是无限制发生的, 也就是这样转移可能会导致一件物品被重复放入背包无限次, 但这不就是我们所要求的吗?<br>　　利用一个问题不正确的解法的错误之处来产生对其他问题的正确解法, 是一个非常有用的能力.在这里, 它产生了一个效率和01背包相同的完全背包做法.<br>　　但是完全背包仍然是一种非常基础的背包问题.但是理解这一问题的解法将是后面所有问题的基础.</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>　　在日常生活中不存在有无限件的物品, 更多的可能是有一定数量的物品, 多重背包就是处理这一类问题.</p>
<h4 id="基础解法-1"><a href="#基础解法-1" class="headerlink" title="基础解法"></a>基础解法</h4><p>　　多重背包的基础解法和完全背包基本相同, 在此不过多解释.</p>
<h4 id="转化为01背包-1"><a href="#转化为01背包-1" class="headerlink" title="转化为01背包"></a>转化为01背包</h4><p>　　做法依然和完全背包相同, 同样可以利用二进制拆分.注意利用二进制拆分其复杂度为$O(nV\sum_{i=1}^n\log_{2}num_{i})$.这个具体的复杂度和数据有关, 所以如果想卡掉你的程序, 构造数据完全可以卡掉.</p>
<h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2:"></a>例题2:</h5><p>　　<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1086" target="_blank" rel="external">51nod 1086 背包问题 V2</a><br>　　因为上面有关完全背包的二进制拆分做法没给出代码所以这里提供一道多重背包的题目并给出二进制拆分做法的代码.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> Input&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;s)</span></span>&#123;</div><div class="line">		<span class="keyword">char</span> ch=getchar();</div><div class="line">		<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">		<span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">	&#125;</div><div class="line">&#125;;<span class="keyword">using</span> <span class="keyword">namespace</span> Input;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,V;</div><div class="line"><span class="keyword">int</span> dp[N];</div><div class="line"><span class="keyword">int</span> num[N],v[N],w[N];</div><div class="line"><span class="keyword">int</span> a[N&lt;&lt;<span class="number">2</span>],b[N&lt;&lt;<span class="number">2</span>];</div><div class="line"><span class="keyword">int</span> tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	read(n),read(V);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</div><div class="line">		read(v[i]),read(w[i]),read(num[i]);</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num[i];j&lt;&lt;=<span class="number">1</span>)&#123;</div><div class="line">				a[tot]=w[i]*j;</div><div class="line">				b[tot]=v[i]*j;</div><div class="line">				num[i]-=j;</div><div class="line">				tot++;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">if</span>(num[i])&#123;</div><div class="line">			a[tot]=w[i]*num[i];</div><div class="line">			b[tot]=v[i]*num[i];</div><div class="line">			num[i]=<span class="number">0</span>;</div><div class="line">			tot++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=V;k&gt;=b[i];k--)</div><div class="line">			dp[k]=max(dp[k],dp[k-b[i]]+a[i]);</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;++i)</div><div class="line">		ans=max(ans,dp[i]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="利用单调队列优化"><a href="#利用单调队列优化" class="headerlink" title="利用单调队列优化"></a>利用单调队列优化</h4><p>　　利用单调队列优化多重背包做法的复杂度为$O(nV)$.但是由于单调队列会有一定的常数， 所以可能会慢一点.<br>　　根据递推公式,<br>$$f_{i.j}=\max { f_{i-1,k}+\frac{j-k}{w_i}\times v_{i}},$$<br>那么要求$$j\equiv k \bmod w_{i}$$<br>设$j=j\times w_i+x$, 那么<br>$$\begin{align}<br>f_{i,j}=&amp;\max{f_{i-1,k}+(j-k) v_{i}}\\<br>=&amp;\max{f_{i-1,k}-kv_{i}}+jv_i<br>\end{align}<br>$$<br>　　因为$f_{i-1,k}-kv_{i}$这个式子只和$k$有关.在更新$f_{i,j}$的时候只需要查询$f_{i-1,k}-kv_{i}$的最大值即可, 利用这个性质可以使用单调队列来维护$\max{f_{i-1,k}-kv_{i}}$.<br>　　因为$j\bmod w_i$会产生不同的余数, 在每次对一件物品进行递推的时候对不同的余数分别维护单调队列即可.下面是对其的伪代码描述:</p>
<h5 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">head ← 0</div><div class="line">tail ← 0</div><div class="line">for i ← 1 to n</div><div class="line">    v ← Input(), w ← Input(), c ← Input()</div><div class="line">    for j ← 0 to c-1</div><div class="line">        head ← 0</div><div class="line">        tail ← 0</div><div class="line">        for k ← 0 to V-j/c</div><div class="line">            while head not= tail and que[tail-1] &lt; f[k*c+j] - k*w</div><div class="line">                do tail ← tail-1</div><div class="line">            que[tail] ← f[k*c+j]-k*w</div><div class="line">            position[tail] ← k</div><div class="line">            if c&lt;k-position[head] </div><div class="line">                do head ← head+1</div><div class="line">            f[k*c+j] ← que[head]+k*w</div><div class="line">        end</div><div class="line">    end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>　　注意: 代码中出现的几条语句, 像第<code>13,14</code>行的语句其作用是去除队列中超出范围之外的元素, 因为$k-position[head]$是$j-k$(这里的$j,k$指的不是伪代码中的), 它意味着往背包中加入了$j-k$个物品$i$, 当它超过物体的数量时, 便没有了意义.其他细节有待斟酌.</p>
<p>　　可以试试使用这个单调队列优化的方法重新写一下例题2.</p>
<h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,V,m;</div><div class="line"><span class="keyword">int</span>  f[N];</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> Input&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;s)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> ch=getchar();</div><div class="line">        <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar());</div><div class="line">        <span class="keyword">for</span>(s=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar());</div><div class="line">    &#125;</div><div class="line">&#125;;<span class="keyword">using</span> <span class="keyword">namespace</span> Input;</div><div class="line"></div><div class="line"><span class="keyword">int</span> val,wei,num;</div><div class="line"><span class="keyword">int</span> v,w,c;</div><div class="line"><span class="keyword">int</span> que[N];</div><div class="line"><span class="keyword">int</span> position[N];</div><div class="line"><span class="keyword">int</span> head,tail;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</div><div class="line">        read(v),read(w),read(c);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v;++j)&#123;</div><div class="line">            head=tail=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v+j&lt;=V;++k)&#123;</div><div class="line">                <span class="keyword">int</span> y=k*v+j;</div><div class="line">                <span class="keyword">while</span>(head!=tail&amp;&amp;que[tail<span class="number">-1</span>]&lt;f[y]-k*w)tail--;</div><div class="line">                que[tail]=f[y]-k*w;</div><div class="line">                position[tail++]=k;</div><div class="line">                <span class="keyword">if</span>(c&lt;k-position[head])head++;</div><div class="line">                f[y]=que[head]+k*w;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=V;i;--i)</div><div class="line">        ans=max(ans,f[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/21/doublebackpacks/" data-id="cjftq8nv0001xe0kekta6t431" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二进制拆分/">二进制拆分</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单调队列/">单调队列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多重背包/">多重背包</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/">信息学竞赛</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/其它/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/我的文档/">我的文档</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/考试/">考试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/题目/">题目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/信息学竞赛/题目/模板/">模板</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/其它/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数学/线性代数/">线性代数</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/">解决方案</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/LaTeX/">LaTeX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/解决方案/VSCode/">VSCode</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2-SAT/">2-SAT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anti-SG/">Anti-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Beatty定理/">Beatty定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDQ分治/">CDQ分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CodeForces/">CodeForces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debug/">Debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Every-SG/">Every-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICG/">ICG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/">LaTeX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lasker-s-Nim/">Lasker's Nim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Link-Cut-Tree/">Link-Cut-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matrix-Tree/">Matrix-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misere-Games/">Misère Games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multi-SG/">Multi-SG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NOIP/">NOIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDOI/">SDOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SG函数/">SG函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TikZ/">TikZ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/">Trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zeckendorf定理/">Zeckendorf定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/copyright/">copyright</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/document/">document</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lca/">lca</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim/">nim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pb-ds/">pb_ds</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pdf/">pdf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source/">source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/with-draw/">with draw</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/一堆简单题/">一堆简单题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三维偏序/">三维偏序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分/">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分答案/">二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维前缀和/">二维前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维线段树/">二维线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二进制拆分/">二进制拆分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/倍增/">倍增</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存池/">内存池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/决策单调性/">决策单调性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分块/">分块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分数规划/">分数规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前缀和/">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区间dp/">区间dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调栈/">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调队列/">单调队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博弈论/">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀数组/">后缀数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/四边形不等式优化/">四边形不等式优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文串/">回文串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基环树/">基环树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆优化Dijkstra/">堆优化Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重标记/">多重标记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重背包/">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/威佐夫博弈/">威佐夫博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/差分约束/">差分约束</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/巴什博弈/">巴什博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带权并查集/">带权并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平衡树/">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异或/">异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强制在线/">强制在线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强联通分量/">强联通分量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并排序/">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速幂/">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打表/">打表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展欧几里得/">扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拆点/">拆点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/指针/">指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排列组合/">排列组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契博弈/">斐波那契博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契数列/">斐波那契数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斜率优化/">斜率优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无限/">无限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大公约数/">最大公约数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大流/">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长上升子序列/">最长上升子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长公共子序列/">最长公共子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构造/">构造</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查分/">查分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树形dp/">树形dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模拟/">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉函数/">欧拉函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版权信息/">版权信息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生成树/">生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/矩阵快速幂/">矩阵快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/秦九韶算法/">秦九韶算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/等差数列/">等差数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性代数/">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/考试/">考试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包/">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/艺术/">艺术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/莫比乌斯反演/">莫比乌斯反演</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规律/">规律</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/解决方案/">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心/">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆元/">逆元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆序对/">逆序对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/错位排列数/">错位排列数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题目/">题目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高精/">高精</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/2-SAT/" style="font-size: 10px;">2-SAT</a> <a href="/tags/Anti-SG/" style="font-size: 10px;">Anti-SG</a> <a href="/tags/Beatty定理/" style="font-size: 11.25px;">Beatty定理</a> <a href="/tags/CDQ分治/" style="font-size: 10px;">CDQ分治</a> <a href="/tags/CodeForces/" style="font-size: 10px;">CodeForces</a> <a href="/tags/Debug/" style="font-size: 10px;">Debug</a> <a href="/tags/Every-SG/" style="font-size: 10px;">Every-SG</a> <a href="/tags/Floyd/" style="font-size: 10px;">Floyd</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/ICG/" style="font-size: 11.25px;">ICG</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/Lasker-s-Nim/" style="font-size: 10px;">Lasker's Nim</a> <a href="/tags/Link-Cut-Tree/" style="font-size: 10px;">Link-Cut-Tree</a> <a href="/tags/Matrix-Tree/" style="font-size: 10px;">Matrix-Tree</a> <a href="/tags/Misere-Games/" style="font-size: 10px;">Misère Games</a> <a href="/tags/Multi-SG/" style="font-size: 11.25px;">Multi-SG</a> <a href="/tags/NOIP/" style="font-size: 17.5px;">NOIP</a> <a href="/tags/Python/" style="font-size: 11.25px;">Python</a> <a href="/tags/SDOI/" style="font-size: 10px;">SDOI</a> <a href="/tags/SG函数/" style="font-size: 10px;">SG函数</a> <a href="/tags/Tarjan/" style="font-size: 10px;">Tarjan</a> <a href="/tags/TikZ/" style="font-size: 10px;">TikZ</a> <a href="/tags/Trie/" style="font-size: 12.5px;">Trie</a> <a href="/tags/Zeckendorf定理/" style="font-size: 10px;">Zeckendorf定理</a> <a href="/tags/bfs/" style="font-size: 10px;">bfs</a> <a href="/tags/copyright/" style="font-size: 10px;">copyright</a> <a href="/tags/document/" style="font-size: 12.5px;">document</a> <a href="/tags/lca/" style="font-size: 10px;">lca</a> <a href="/tags/nim/" style="font-size: 11.25px;">nim</a> <a href="/tags/pb-ds/" style="font-size: 10px;">pb_ds</a> <a href="/tags/pdf/" style="font-size: 16.25px;">pdf</a> <a href="/tags/source/" style="font-size: 10px;">source</a> <a href="/tags/with-draw/" style="font-size: 11.25px;">with draw</a> <a href="/tags/一堆简单题/" style="font-size: 10px;">一堆简单题</a> <a href="/tags/三维偏序/" style="font-size: 10px;">三维偏序</a> <a href="/tags/二分/" style="font-size: 10px;">二分</a> <a href="/tags/二分答案/" style="font-size: 11.25px;">二分答案</a> <a href="/tags/二维前缀和/" style="font-size: 10px;">二维前缀和</a> <a href="/tags/二维线段树/" style="font-size: 10px;">二维线段树</a> <a href="/tags/二进制拆分/" style="font-size: 10px;">二进制拆分</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/倍增/" style="font-size: 13.75px;">倍增</a> <a href="/tags/内存池/" style="font-size: 11.25px;">内存池</a> <a href="/tags/决策单调性/" style="font-size: 10px;">决策单调性</a> <a href="/tags/分块/" style="font-size: 11.25px;">分块</a> <a href="/tags/分数规划/" style="font-size: 11.25px;">分数规划</a> <a href="/tags/前缀和/" style="font-size: 10px;">前缀和</a> <a href="/tags/动态规划/" style="font-size: 20px;">动态规划</a> <a href="/tags/区间dp/" style="font-size: 10px;">区间dp</a> <a href="/tags/单调栈/" style="font-size: 10px;">单调栈</a> <a href="/tags/单调队列/" style="font-size: 11.25px;">单调队列</a> <a href="/tags/博弈论/" style="font-size: 18.75px;">博弈论</a> <a href="/tags/后缀数组/" style="font-size: 11.25px;">后缀数组</a> <a href="/tags/四边形不等式优化/" style="font-size: 10px;">四边形不等式优化</a> <a href="/tags/回文串/" style="font-size: 10px;">回文串</a> <a href="/tags/图论/" style="font-size: 13.75px;">图论</a> <a href="/tags/基环树/" style="font-size: 10px;">基环树</a> <a href="/tags/堆优化Dijkstra/" style="font-size: 10px;">堆优化Dijkstra</a> <a href="/tags/多重标记/" style="font-size: 10px;">多重标记</a> <a href="/tags/多重背包/" style="font-size: 10px;">多重背包</a> <a href="/tags/威佐夫博弈/" style="font-size: 11.25px;">威佐夫博弈</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/差分约束/" style="font-size: 11.25px;">差分约束</a> <a href="/tags/巴什博弈/" style="font-size: 10px;">巴什博弈</a> <a href="/tags/带权并查集/" style="font-size: 10px;">带权并查集</a> <a href="/tags/平衡树/" style="font-size: 11.25px;">平衡树</a> <a href="/tags/并查集/" style="font-size: 10px;">并查集</a> <a href="/tags/异或/" style="font-size: 11.25px;">异或</a> <a href="/tags/强制在线/" style="font-size: 10px;">强制在线</a> <a href="/tags/强联通分量/" style="font-size: 10px;">强联通分量</a> <a href="/tags/归并排序/" style="font-size: 10px;">归并排序</a> <a href="/tags/快速幂/" style="font-size: 10px;">快速幂</a> <a href="/tags/打表/" style="font-size: 10px;">打表</a> <a href="/tags/扩展欧几里得/" style="font-size: 10px;">扩展欧几里得</a> <a href="/tags/拆点/" style="font-size: 10px;">拆点</a> <a href="/tags/拓扑排序/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/指针/" style="font-size: 12.5px;">指针</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/搜索/" style="font-size: 16.25px;">搜索</a> <a href="/tags/数学/" style="font-size: 10px;">数学</a> <a href="/tags/数论/" style="font-size: 10px;">数论</a> <a href="/tags/斐波那契博弈/" style="font-size: 10px;">斐波那契博弈</a> <a href="/tags/斐波那契数列/" style="font-size: 10px;">斐波那契数列</a> <a href="/tags/斜率优化/" style="font-size: 11.25px;">斜率优化</a> <a href="/tags/无限/" style="font-size: 10px;">无限</a> <a href="/tags/最大公约数/" style="font-size: 10px;">最大公约数</a> <a href="/tags/最大流/" style="font-size: 10px;">最大流</a> <a href="/tags/最小生成树/" style="font-size: 11.25px;">最小生成树</a> <a href="/tags/最短路/" style="font-size: 16.25px;">最短路</a> <a href="/tags/最长上升子序列/" style="font-size: 11.25px;">最长上升子序列</a> <a href="/tags/最长公共子序列/" style="font-size: 10px;">最长公共子序列</a> <a href="/tags/构造/" style="font-size: 11.25px;">构造</a> <a href="/tags/查分/" style="font-size: 10px;">查分</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/树形dp/" style="font-size: 16.25px;">树形dp</a> <a href="/tags/树状数组/" style="font-size: 11.25px;">树状数组</a> <a href="/tags/模拟/" style="font-size: 17.5px;">模拟</a> <a href="/tags/模板/" style="font-size: 16.25px;">模板</a> <a href="/tags/欧拉函数/" style="font-size: 10px;">欧拉函数</a> <a href="/tags/测试/" style="font-size: 11.25px;">测试</a> <a href="/tags/版权信息/" style="font-size: 10px;">版权信息</a> <a href="/tags/生成树/" style="font-size: 13.75px;">生成树</a> <a href="/tags/矩阵快速幂/" style="font-size: 11.25px;">矩阵快速幂</a> <a href="/tags/秦九韶算法/" style="font-size: 10px;">秦九韶算法</a> <a href="/tags/等差数列/" style="font-size: 10px;">等差数列</a> <a href="/tags/线性代数/" style="font-size: 11.25px;">线性代数</a> <a href="/tags/线段树/" style="font-size: 17.5px;">线段树</a> <a href="/tags/网络流/" style="font-size: 10px;">网络流</a> <a href="/tags/考试/" style="font-size: 10px;">考试</a> <a href="/tags/背包/" style="font-size: 11.25px;">背包</a> <a href="/tags/艺术/" style="font-size: 11.25px;">艺术</a> <a href="/tags/莫比乌斯反演/" style="font-size: 11.25px;">莫比乌斯反演</a> <a href="/tags/规律/" style="font-size: 11.25px;">规律</a> <a href="/tags/解决方案/" style="font-size: 15px;">解决方案</a> <a href="/tags/计划/" style="font-size: 13.75px;">计划</a> <a href="/tags/贪心/" style="font-size: 15px;">贪心</a> <a href="/tags/逆元/" style="font-size: 10px;">逆元</a> <a href="/tags/逆序对/" style="font-size: 10px;">逆序对</a> <a href="/tags/错位排列数/" style="font-size: 10px;">错位排列数</a> <a href="/tags/题目/" style="font-size: 10px;">题目</a> <a href="/tags/高精/" style="font-size: 11.25px;">高精</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/dphigher/">动态规划题目选做</a>
          </li>
        
          <li>
            <a href="/2018/04/10/dpeasypros/">历年NOIP简单动态规划题目选做</a>
          </li>
        
          <li>
            <a href="/2018/04/07/noip2014d2/">NOIP 2014 Day1</a>
          </li>
        
          <li>
            <a href="/2018/04/07/noip2014d1/">NOIP 2014 Day1</a>
          </li>
        
          <li>
            <a href="/2018/04/06/SuffixArray/">后缀数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>